# 신장트리란?

주어진 방향성이 없는 그래프의 부분 그래프들 중에서 `모든 정점을 포함하는 트리`를 의미한다.

부분 그래프는 주어진 그래프에서 일부 간선과 정점만을 택해서 구성한 새로운 트리를 의미한다.

## 최소신장트리란?

한 그래프에서 여러가지의 신장트리를 찾을 수 있다. 이 때, 다양한 케이스의 신장트리중 간선끼리의 합이 최소인 신장트리를 최소신장트리라고 한다.

최소신장트리는 한 그래프에서 여러 케이스가 나올 수 있다.

### 예시문제

N개의 도시가 존재하는 상황에서 두 도시 사이에 도로를 놓아 전체 도시가 연결될 수 있도록 하는 경우

- 이 때 도로 설치비용이 도시와 도시마다 다를 때, 설치 비용을 최소로하기

## 크루스칼 알고리즘이란?

간선을 크기의 오르차순으로 정렬하고 제일 낮은 비용의 간선을 선택한다.

현재 선택한 간선이 정점, u,v를 연결하는 간선이라고 할 때, 만약 u와 v가 같은 그룹이라면 아무 것도 하지 않고 넘어간다. 만약 다른 그룹이라면 같은 그룹으로 만들고 현재 선택한 간선을 최소 신장 트리에 추가한다.

최소 신장 트리에 v-1개의 간선을 추가시켰다면 과정을 종료하고 그렇지 않다면 그 다음으로 비용이 작은 간선을 선택한 후 2번 과정을 반복한다.

### 요약

크루스칼 알고리즘은 사이클을 만들어내지 않는 선에서 비용이 작은 간선부터 최소 신장 트리에 편입시키는 그리디 알고리즘이다

### 주의사항

같은 그룹에 있는 두 정점을 연결하는 간선을 골랐을 때 해당 간선을 해당 간선을 최소 신장 트리에 넣지 않는 이유는 해당 간선으로 인해 사이클이 생기기 때문이다.

Union FInd를 알면 시간복잡도를 낮춰서 구현할 수 있다.

```python
import os
import sys

def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

file_path = os.path.join(os.path.dirname(__file__), "1.txt")
sys.stdin = open(file_path, "r")

v, e = map(int, input().split())
parent = [0] * (v + 1) # 부모 테이블 초기화하기

edges = []
answer = 0

# 테이블 초기화
for i in range(1, v + 1):
    parent[i] = i

for _ in range(e):
    a, b, cost = map(int, input().split())
    # 비용순으로 정렬하기 위해서 튜플의 첫 번째 원소를 비용으로 설정
    edges.append((cost, a, b))

edges.sort()

for edge in edges:
    cost, a, b = edge
    # 사이클이 발생하지 않는 경우에만 집합에 포함
    if find_parent(parent, a) != find_parent(parent, b):
        union_parent(parent, a, b)
        answer += cost

print(answer)
```

# 프림 알고리즘

임의의 정점을 선택해 최소 신장 트리에 추가한다.

최소 신장 트리에 포함된 정점과 최소 신장 트리에 포함되지 않은 정점을 연결하는 간선 중 비용이 가장 작은 것을 최소 신장 트리에 추가한다.

최소 신장 트리에 v-1개의 간선이 추가도리 떄까지 2번 과정을 반복한다.

### 요약

프림 알고리즘은 임의의 한 정점에서 시작해 매번 가장 낮은 비용의 간선을 찾아 점점 뻗어가는 모양이다.

### 주의사항

프림 알고리즘을 제대로 구현하기 위해서는 우선순위 큐를 활용해야한다. 최소 시장 트리에 포함되는 않은 정점을 연결하는 간선 중 비용이 가장 작은 것을 매번 확인하면 시간복잡도가 높아지기 때문이다. 그렇기 때문에 아래와 같은 방법으로 구현할 수 있다.

- 임의 정점을 선택해 최소 시장 트리에 추가, 해당 장점과 연결되 모든 간선을 우선순위 큐에 추가
- 우선순위 큐에서 비용이 가장 작은 간선 선택
- 만약 해당 간선이 최소 신장 트리에 포함된 두 장점을 연결한다면 아무 것도 하지 않고 넘어가기, 해당 간선이 최소 신장 트리에 포함된 정점 u와 포함되지 않은 정점 v를 연결한다면 해당 간선과 정점 v를 최소 신장 트리에 추가 후 정점 v와 최소 신장 트리에 포함되지 않은 정점을 연결하는 모든 간선을 우선순위 큐에 추가
- 최소 시장 트리에 v-1개의 간선이 추가 될 떄까지 2,3번 과정 반복

# 참고자료

https://blog.encrypted.gg/1024

https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html
