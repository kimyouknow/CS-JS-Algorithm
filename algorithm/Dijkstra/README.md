# 다익스트라 알고리즘

다익스트라(dijkstra) 알고리즘은 그래프에서 한 정점(노드)에서 다른 정점까지의 최단 경로를 구하는 알고리즘 중 하나이다. 이 과정에서 도착 정점 뿐만 아니라 모든 다른 정점까지 최단 경로로 방문하며 각 정점까지의 최단 경로를 모두 찾게 된다. 매번 최단 경로의 정점을 선택해 탐색을 반복하는 것이다.

# 그래프의 가중치가 없을 때는 BFS

BFS는 너비 우선 탐색(Breadth First Search)의 약자로, DFS 처럼 그래프에서 쓰일 수 있는 탐색 알고리즘이다.

BFS는 **가중치가 없는 그래프의 최단경로를 찾는 경우**의 응용 말고는, 잘 쓰이는 응용이 없는듯 하다.

# **가중치가 다르고, 음수간선이 없을땐 다익스트라**

래프의 각 간선의 가중치가 서로 차이가 없는 그래프의 경우에는 BFS를 이용해서 시작점으로부터 각 정점의 최단거리를 알 수 있다. 하지만, 각 간선의 가중치가 다 같지만은 않다면 BFS를 사용하기 어렵다. 단순히 depth로만 최단 거리가 정해지는 것이 아니기 때문이다. 같은 depth(층위)에 있는 노드끼리 이동하는 것은 고려하지 않는다.

예를 들어 A,B,C 3개의 정점이 있을 때, A가 B와 C와 연결되어 있고, B와 C가 연결되어 있다고 하자. 이 때, A는 depth가 1이고, B와 C는 depth가 2가 된다. A-B의 가중치가 3, A-C의 가중치가1, B-C의 가중치가 1이라고 했을 때, A → B로 가는 최단 경로는 무엇일까? depth를 기준으로 하면 A → B가 된다. **가중치를 고려한다면 A → C → B가 되지만, depth를 기준으로 탐색하는 BFS에서는 해당 경로가 고려되지 않는다.**

가중치가 있는 그래프에서 BFS를 사용할 수 없는 이유는, BFS가 Greedy한 알고리즘이 아니기 때문이다. 이와 달리, 다익스트라 알고리즘은 `Greedy`하다. 그리디한 이유는 **최소 거리에 최소 거리를 붙이면 최소 거리가 될 것이다라는 논리가 함축**되어 있기 때문이다.

> 증명 및 가정은 [최단거리 문제 알고리즘에 대한 궁금증 정리](https://jypthemiracle.medium.com/최단거리-문제-알고리즘에-대한-궁금증-정리-5b1b813ba1b3) 해당 링크를 참고

# 동작 단계

1. 출발 노드와 도착 노드를 설정한다
2. '최단 거리 테이블'을 초기화한다
3. 현재 위치한 노드의 인접 노드 중 방문하지 않은 노드를 구별하고, 방문하지 않은 노드 중 거리가 가장 짧은 노드를 선택한다. 그 노드를 방문 처리한다.
4. 해당 노드를 거쳐 다른 노드로 넘어가는 간선 비용(가중치)을 계산해 '최단 거리 테이블'을 업데이트한다.
5. 3번과 4번의 과정을 반복한다.

'최단 거리 테이블'은 1차원 배열로, N개 노드까지 오는 데 필요한 최단 거리를 기록한다. N개(1부터 시작하는 노드 번호와 일치시키려면 N + 1개) 크기의 배열을 선언하고 큰 값을 넣어 초기화시킨다.

'노드 방문 여부 체크 배열'은 방문한 노드인지 아닌지 기록하기 위한 배열로, 크기는 '최단 거리 테이블'과 같다. 기본적으로는 `False`로 초기화하여 방문하지 않았음을 명시한다.

## 시간복잡도

최소비용을 단순히 선형 탐색으로 찾도록 하면 다익스트라의 시간 복잡도가 O(N^2)가 된다. 따라서 최대한 빠르게 작동시켜야 하는 경우 힙 구조를 활용한 우선순위 큐로 시간 복잡도를 O(N \* logN)으로 만들 수 있다.

## 구현1: 순차 탐색

노드의 개수가 v라고 할 때 O(v^2)의 시간복잡도를 가진다.

'방문하지 않은 노드 중 거리값이 가장 작은 노드'를 선택해 다음 탐색 노드로 삼는다. 해당 노드를 찾는 방식에서 순차탐색을 하게되는데, 거리 테이블의 앞에서부터 찾아야하므로 노드의 개수만큼 탐색해야한다.

## 구현2: 우선순위 큐

거리 값을 담을 우선순위 큐는 힙으로 구현하고, 만약 최소 힙으로 구현한다면 매번 루트 노드가 최소 거리를 가지는 노드가 될 것이다. 우선순위 큐에서 사용할 '우선순위'의 기준은 '시작 노드로부터 가장 가까운 노드'가 된다. 따라서 큐의 정렬은 최단 거리인 노드를 기준으로 최단 거리를 가지는 노드를 앞에 배치한다.

위의 순차 탐색을 쓰는 구현과는 다르게 우선순위 큐를 사용하면 방문 여부를 기록할 배열은 없어도 된다. 우선순위 큐가 알아서 최단 거리의 노드를 앞으로 정렬하므로 기존 최단 거리보다 크다면 무시하면 된다. 만약 `기존 최단거리보다 더 작은 값을 가지는 노드가 있다면 그 노드와 거리를 우선순위 큐에 넣는다`. 우선순위 큐에 삽입되는 형태는 `<거리, 노드>` 형태가 된다.

## 관련문제

https://www.acmicpc.**net**/problem/1753

## 참고자료

[https://m.blog.naver.com/ndb796/221234424646](https://m.blog.naver.com/ndb796/221234424646)

[https://velog.io/@kasterra/핵심-자료구조-그래프-최단-경로-탐색](https://velog.io/@kasterra/%ED%95%B5%EC%8B%AC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%B5%9C%EB%8B%A8-%EA%B2%BD%EB%A1%9C-%ED%83%90%EC%83%89)

[https://velog.io/@717lumos/알고리즘-다익스트라Dijkstra-알고리즘](https://velog.io/@717lumos/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BCDijkstra-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

[https://jypthemiracle.medium.com/최단거리-문제-알고리즘에-대한-궁금증-정리-5b1b813ba1b3](https://jypthemiracle.medium.com/%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC-%EB%AC%B8%EC%A0%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B6%81%EA%B8%88%EC%A6%9D-%EC%A0%95%EB%A6%AC-5b1b813ba1b3)
