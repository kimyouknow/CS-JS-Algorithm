링크: [https://www.acmicpc.net/problem/14395](https://www.acmicpc.net/problem/14395)

[백준] 14395-g5-4연산 그래프 탐색, 너비 우선 탐색

# 느낀 점

BFS로직은 쉽게 구현했지만 처음에 방문배열을 선언할 때 배열 선언문에서 어려움을 겪었다.

javascript배열을 선언할 때 주로 Array.from을 사용했는데

Array.from({length:n}, () => 0) 의 경우 배열을 생성하면서 값을 채워 넣기 때문에 O(n) 의 시간 복잡도를 갖고

Array(n).fill(0) 의 경우 배열을 생성후 다시 순회하며 값을 채워 넣기 때문에 O(n) + O(n) 의 시간 복잡도를 갖는다고 생각했다.

어쨋든 둘다 배열은 다시 순회하는 것 같아 Array(n)으로만 선언해서 풀었더니 시간복잡도 확실히 줄었음을 알 수 있었다.

![시간복잡도](./스크린샷%202023-02-06%20오전%209.30.25.png)

이후 set 이랑 객체 형식으로 방문배열을 선언했는데 Array(n)이나 visited = []와 같은 빈 배열 선언해도 비슷한 시간이 걸렸음을 확인할 수 있었다.

javascript 배열은 내부적으로 객체로 구현되어 있어 미리 길이만큼 선언하지 않고 key, value값으로 접근해도 상관없을 듯 하다.

# 문제 읽기

정수 s의 값을 t로 바꾸는 최소 연산 횟수

(1 ≤ s, t ≤ 10^9)

s와 t가 같은 경우에는 0을, 바꿀 수 없는 경우에는 -1을 출력

방법이 여러 가지면 사전 순으로 앞서는 것을 출력한다. 연산의 아스키 코드 순서는 '\*', '+', '-', '/' 이다.

# 1트: 25m ✅

'\*', '+', '-', '/' 순서대로 BFS

예외

- 바꿀 수 없는 경우: 무한루프를 도는 경우 → 방문처리해서 이전에 계산한 값이면 계산하지 않고 넘어가기
