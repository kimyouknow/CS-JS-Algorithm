링크: [https://www.acmicpc.net/problem/16197](https://www.acmicpc.net/problem/16197)

[백준] 16197-g4-두 동전 너비 우선 탐색 백트래킹

# 느낀 점

그래프에서 각 간선이 같은 조건에서 최단거리 구하기여서 bfs로 풀었어야 하는데 처음에 잘못생각해서 dfs로 풀었다. 다행히 10번 이상이면 종료되게 문제가 구성되어 있어 풀렸는데 다음부터는 잘 봐야겠다.

# 문제 읽기

N×M 크기의 보드 ( 1 ≤ n,m ≤ 20)

- 각 칸은 비어있거나, 벽
- o: 동전
- . : 빈 칸
- #: 벽
- 두 개의 빈 칸에는 동전이 하나씩 있고, 두 동전의 위치는 다름

4개의 버튼

- 상하좌우
- 버튼을 누르면 두 동전이 버튼에 쓰여 있는 방향으로 동시에 이동

이동로직

- 동전이 이동하려는 칸이 벽이면 동전은 이동하지 않는다.
- 동전이 이동하려는 방향에 칸이 없으면 동전은 보드 바깥으로 떨어짐
- 그 외 경우에는 이동하려는 방향으로 한 칸 이동
- 이동하려는 칸에 동전이 있어도 한 칸 이동

두 동전 중 하나만 보드에서 떨어뜨리기 위해 버튼을 최소 몇 번 눌러야하는지 구하는 프로그램을 작성

만약, 두 동전을 떨어뜨릴 수 없거나, 버튼을 10번보다 많이 눌러야 한다면, -1을 출력한다.

# 1트: 44m ✅ 재귀를 활용한 완전탐색

n = col

m = row

dfs(idx, xc,xr, yc,yr)

(xc,xr) 이나 (yc,yr) 중 하나면 밖이면 종료16

if(idx ≥ 10)

둘 다 있으면 -1

종료

for(4 방향 경우)

if(둘 중 하나만 가능) 정답

if( 둘 다 불가능) 종료

if( 벽인지 확인) 동전1,2 위치 업데이트

dfs(idx+1)

이동함수(동전1위치, 동전2위치)

# 2트: BFS

방문처리

위와 비슷한 로직으로 queue를 활용한 처리

while

if(idx ≥ 10)

둘 다 있으면 -1

종료

for(4 방향 경우)

if(둘 중 하나만 가능) 정답

if( 둘 다 불가능) 종료

if( 벽인지 확인) 동전1,2 위치 업데이트

if(방문여부) continue

queue.push

동전1,2 위치 업데이트

for문 종료되었는데 flag가 false면 재귀함수 종료
