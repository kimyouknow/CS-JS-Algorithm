[https://www.acmicpc.net/problem/1253](https://www.acmicpc.net/problem/1253)

백준 1253 g4 좋다

# 느낀 점

투 포인터로 구현해야 시간초과가 발생하지 않을 것이라는 예상은 맞았다.

하지만 처음 접근할 때 포인터를 3개를 활용해서 세부구현에서 어려움을 겪었다.

(l,r,k(합)이라는 3개의 포인터를 두고, l = 0, r = 1, k = 2부터 시작해 특정조건에 따라 포인터들이 이동하게 함)

다른 사람풀이를 참고해 합을 따로 포인터가 아닌 별개의 for문으로 탐색하고 포인터를 양끝값으로 두고 풀었더니 쉽게 풀 수 있었다.

# 문제 읽기

n개의 수 중에서 어떤 수가 다른 두 수 개의 합으로 나타낼 수 있다면 “좋다”

N개의 수가 주어지면 그 중에서 좋은 수의 개수 몇 개인지 출력

수의 위치가 다르면 값이 같아도 다른 수로 취급

N(1 ≤ N ≤ 2,000),(|Ai | ≤ 1,000,000,000, Ai는 정수)

# 1트: 투포인터 40m

정렬

투포인터 탐색

l, r, k(합)

while문의 조건( l < 마지막 두 번째 인덱스까지)

current = arr[l] + arr[r]

target = arr[k]

if(current === target) k++, answer++

if(current > target) (k+1이 n보다 작을 때)k++

if(current < target)

k < n-1 ⇒ k++, continue

if (r + 1 ≥ k) l++

else r++

# 2트: 투포인터 40m ✅

정렬

for문으로 배열을 하나씩 순회: 찾고자 하는 값

투포인터를 양 끝 값으로 설정: left = 0, rigth = n-1

while문(l < r)

l === i → l— , r === i → r— (i, l, r이 모두 달라야함)

i가 가리키는 값 > l이 가리키는 값 + r이 가리키는 값 → l증가

i가 가리키는 값 < l이 가리키는 값 + r이 가리키는 값 → r감소

i가 가리키는 값 === l이 가리키는 값 + r이 가리키는 값 → answer++
