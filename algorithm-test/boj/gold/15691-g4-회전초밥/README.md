링크: [https://www.acmicpc.net/problem/15961](https://www.acmicpc.net/problem/15961)

[백준] 15691-g4-회전초밥 [두 포인터](https://www.acmicpc.net/problem/tag/80) [슬라이딩 윈도우](https://www.acmicpc.net/problem/tag/68)

# 느낀 점

시간복잡도를 줄이기 위해 구간이 이동할 때마다 겹치는 부분을 고려한다. 매 구간마다 전부 다시 계산하는게 아님

# 문제 읽기

- 회전 초밥은 손님이 마음대로 고르고, 먹은 초밥만큼 계산
- 벨트의 임의의 한 위치부터 K개의 접시를 연속해서 먹을 경우 할인된 정액 가격으로 제공
- 각 고객에게 초밥의 종류가 하나가 쓰인 쿠폰을 발행, 1번 행사에 참가할 경우 쿠폰에 적힌 종류의 초밥 하나를 무료 제공
  - 해당 초밥이 벨트에 없으면 요리사가 새로 만들어서 제공

손님이 먹을 수 있는 초밥 가짓수의 최댓값

회전 초밥 벨트에 놓인 접시의 수 N,

초밥의 가짓수 d,

연속해서 먹는 접시의 수 k,

쿠폰 번호 c

2 ≤ N ≤ 3,000,000

2 ≤ d ≤ 3,000

2 ≤ k ≤ 3,000 (k ≤ N),

1 ≤ c ≤ d

## 1트: 50m

간격: k

초밥 벨트에 있는 놓인 접시의 수 N

0 ≤ i < k

i ~ i + k - 1

i + k - 1 ≥ n ? i + k - 1 - n : i + k - 1

n = 8, k = 4, i + k - 1

0123 1234 2345 3456 4567 5678(5670)

각 슬라이딩마다

- if(각방문[i] || i === c) continue
- 각방문[i] = true
- acc++

시간복잡도; O(n \* k) → 시간줄이기

- if(각방문[i] ) break
- if(visited[target]
  s = i로 넘기기

## 2트: 50m

각 슬라이딩마다 k번만큼 비교하는게 아니라 가운데 교집합을 공유한 상태에서 끝값만 옮기기

시간복잡도; O(n)

0[123] → [123]4

while(s < n)

- e = i >= n ? i - n : i;
- target !== C
  - 방문하지 않았으면 방문처리 후 누적값 증가, 이미 슬라이딩 내 방문했다면 누적값 증가하지 않음
- 슬라이딩 개수 === k
  - 슬라이딩 첫 값 제거: s = i - k + 1 >= n ? i - n - k + 1 : i - k + 1;
  - 슬라이딩 내 방문한 기록이 없으면 누적값에서 제거
