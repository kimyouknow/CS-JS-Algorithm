링크: [https://www.acmicpc.net/problem/1941](https://www.acmicpc.net/problem/1941)

[백준] 1941-g3-소문난 칠공주 백트래킹, DFS, BFS, 조합

# 느낀 점

문제 로직은 생각보다 단순하다.

- 1번: 25명 중 7명 뽑기
- 2번: 7명 중 이다솜파 학생이 적어도 4명인지 확인
- 3번: 7명이 모두 인접해 있는지 확인

1트에서는 3번 로직을 잘못생각했다. idx를 현재 탐색하는 번호라고 하면 idx를 기준으로 상하좌우로 뻗어나가면 3번 조건이 자동으로 만족될 것이라고 생각했다. 그런데 이렇게 하면 아래 2번째 경우처럼 가지를 치는 형태는 탐색하지 않는 문제가 발생한다.

```jsx
.....    .....
SYSYS    SYSYS
....Y    .Y...
....S    .S...
.....    .....
```

2트에서 결국 현재 idx를 넣을지 말지 2가지 경우를 갈래처러 dfs를 돌린 뒤, 뽑은 인원이 7명이 넘을 때 7명이 서로 인접한지 확인하는 로직을 구성했다.

`시간복잡도를 줄이고 싶어서 고민을 좀 했는데 줄이지 못했다.`

# 문제 읽기

총 25명의 여학생들로 이루어진 여학생반은 5×5의 정사각형 격자 형태로 자리가 배치

규칙

- 7명 학생으로 구성
- 7명의 자리는 서로 가로나 세로로 인접
- 이다솜파가 적어도 4명 이상
- 임도연파도 있어도 됨

총 25명의 여학생들로 이루어진 여학생반은 5×5의 정사각형 격자 형태로 자리가 배치

격자

- S: 이다솜
- Y: 임도연

# 1트: 탐색 과정 오류

경로 순서는 다른데 구성이 똑같은 배열 판별하기

dfs (idx, r,c, acc)

if(idx > 7) {

이미 있는 경로면 continue

acc에서 이다솜파 4명이상 아니면 continue

answer++

}

for( 상하좌우)

nr,nc 갱신

nr, nc 0보다 작거나 5이상이면 continue

visitied[nr][nc] === true : conitnue

dfs(idx+1, nr, nc, […acc, map[nr][nc])

visitied[nr][nc] = false

시간복잡도

- `25 * (4 ^ 7)`

# 2트: 40m ✅

for문을 1트에서 처럼 ( 상하좌우)로 돌면 주어진 문제 예시에서 두 번째 케이스를 탐색하지 않는다.

```jsx
.....    .....
SYSYS    SYSYS
....Y    .Y...
....S    .S...
.....    .....
```

모든 경우를 전부 탐색 : `2 ^ 25 +`

이후 7개 이상쌓이면 인접해 있는지 확인

r,c ⇒ r \* 5 + c ⇒ `idx`

dfs(idx, acc)

if(acc.length > 7) {

인접해 있는지 확인

이미 있는 경로면 continue

acc에서 이다솜파 4명이상 아니면 continue

answer++

}

dfs(idx + 1, [...acc, idx + 1]);
dfs(idx + 1, [...acc]);

# 3트: 40m

시간복잡도 개선 실패
