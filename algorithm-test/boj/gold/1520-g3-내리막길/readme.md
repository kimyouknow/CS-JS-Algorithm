링크: [https://www.acmicpc.net/problem/1520](https://www.acmicpc.net/problem/1520)

[백준] 1520-g3-내리막길 다이나믹 프로그래밍 그래프 이론 그래프 탐색 깊이 우선 탐색

# 느낀 점

dp를 채우는 기준을 다르게 해서 생각해봤다.

1트에서 `dp[r][c]는 (0,0)에서부터 map[r][c]로 도달할 수 있는 방법의 가지 수` 라고 설정했는데 논리적 오류로 인해 풀기 어려웠다.

논리적 오류: dp[3][3]을 구하더라도 dp[4][3]을 구할 때 돌아서 가는 길이 생기기 떄문에 활용할 수 없다.

2트에서는 `dp[r][c]는 r,c에서 map[n-1][m-1]까지 c개의 경로로 도달할 수 있다는 뜻`이라고 설정했다.

# 문제 읽기

칸: (r,c)

- 지점의 높이
- 이동: 상하좌우, 인접만 가능

제일 왼쪽 위 → 제일 오른쪽 아래

- 항상 높이가 더 낮은 지점으로만 이동

항상 내리막길로만 이동하는 경로의 개수

세로의 크기 M과 가로의 크기 N

M과 N은 각각 500이하의 자연수이고, 각 지점의 높이는 10000이하의 자연수

# 1트: DP, 60m

(m,n) → (r,c)

DFS, 백트래킹

- 최단 경로가 아닌 갈 수 있는 모든 경우의 수
- 시간초과날듯: 4 ^ (500 \* 500)

방문처리할 필요 없음 → 더 낮은 곳으로만 이동 가능하기 때문에 본인을 재방문할 일 없음

dp?

- `dp[r][c]는 (0,0)에서부터 map[r][c]로 도달할 수 있는 방법의 가지 수`
- (r,0), (0,c)를 모두 1초기화
  - (0,0)과 이어진 가장자리는 1일 수 밖에 없음
- (r,c)에서 상하좌우 비교
  - 상하좌우의 값 > map[r][c]
    - dp[r][c]값이 없으면 dp[r][c] += 1
    - dp[r][c]값이 있으면 dp[r][c] += 해당 값
  - 상하좌우의 값 ≤ map[r][c]
    - dp[r][c] = 0

```tsx
10 9 8
9 6 5  -> 6으로 갈 수 있는 경로 2가지
----
8 7 4 -> 6으로 갈 수 있는 경로 3가지로 늘어남
```

위와 같은 풀이로 하면

50 → 45 → 37 → 32 → 20 → 17 로가는 경로에서 논리적 오류 발생

20에서 오른쪽 수가 25인데 아직 방문하지 않아 dp[r][c] += 1

17에서 오른쪽 수가 28인데 아직 방문하지 않아 dp[r][c] += 1

그런데 28은 논리적으로 지나갈 수 없는 부분이어서 0이되어야함.

```tsx
50 45 37 32 30
35 50 40 20 25
30 30 25 17 28
27 24 22 15 10

[ 1, 1, 1, 1, 1 ],
[ 1, 0, 0, 2, 2 ],
[ 1, 0, 0, 3, 0 ],
[ 1, 1, 1, 4, 4 ]
```

# 2트: DFS + DP: 40m

DFS로 탐색하면서 이전에 탐색했던 값이면 통과하기

- 이전에 탐색했던 값을 dp에 저장해서 활용
- 기존에는 “dp[r][c]는 (0,0)에서부터 map[r][c]로 도달할 수 있는 방법의 가지 수”라고 했는데 반대로
  - ⇒ `dp[r][c]는 r,c에서 map[n-1][m-1]까지 c개의 경로로 도달할 수 있다는 뜻`

```tsx
dfs(r, c);

// 방문한 적이 있으면 해당 값을 사용
// 방문처리

// 현재 값보다 주변 값이 더 작으면 dfs 탐색 진행
if (map[nr][nc] < map[r][c]) dp[r][c] += dfs(nr, nc);
```
