링크: [https://www.acmicpc.net/problem/2206](https://www.acmicpc.net/problem/2206)

# 느낀 점

단순한 최단 거리 문제가 아니다. 벽을 한 번 부시고 갈 수 있기 때문에 방문 체크를 할 때 고려해야 할 부분이 있다.

만약 장애물을 부술 수 있다면 경우의 수가 변경된다. 장애물을 부술 수 없는 상황에서 최단거리는 장애물을 부실 수 있는 상황에서 최단거리와 다르다.

# 문제 읽기

N×M의 행렬로 표현되는 맵

N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)

0: 이동 가능

1: 이동할 수 없는 벽

(1, 1)에서 (N, M)의 위치로 이동, 최단 경로

최단 경로

- 시작, 끝 칸 포함

이동 가능한 경로

- 상하좌우
- 한 개의 벽을 부수고 이동하는 것이 더 짧으면 한 개까지 부수기 가능

## 1트: 50m

(N,M) → (r,c) (n-1, m-1)

벽을 한 개까지 부수기 가능

벽을 만났을 때 할 행동

- 이전에 벽을 한 개 부셨는지 확인
- 아직 안 부심 → 부수고 이동
- 이미 부심 → 이동못함

queue([r,c, acc, chance])

- r,c → 좌표
- acc: 누적 이동 횟수
- chance ? 벽 부수기 가능 : 벽 못부심

문제

```jsx
6 4
0100
0110
0000
0000
0111
0010
```

상황에서

(4,1) → (5,1)이 먼저 실행되고 그 다음에 (5,0) → (5,1)이 실행돼서 (5,1)이 이미 방문처리 되서 탐색하지 않음

## 2트: 44m

방문배열을 3차원으로 만들기

visited[r][c][2] ⇒ 2는 chance여부

벽을 만났을 때 안 만났을 때를 구분하기

- 벽을 만났음
  - 처음만남
  - 이미 뚫음
- ## 벽을 만나지 않았음

> 런타임에러;;

## 3트

입력 방식 수정

수정전

```jsx
const fs = require('fs');
const rawInputs = fs
  .readFileSync('/dev/stdin')
  .toString()
  .trim()
  .split('\n')
  .map((e) => e.split('').map((v) => +v));

const [[n, _, m], ...arr] = rawInputs;
6,
  6,
  [
    [0, 0, 0, 0, 0, 0],
    [1, 1, 1, 1, 1, 0],
    [0, 1, 0, 0, 0, 0],
    [0, 1, 0, 1, 1, 1],
    [0, 1, 0, 0, 1, 1],
    [0, 1, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0],
  ];
```

수정 후

```jsx
const fs = require('fs');
const rawInputs = fs.readFileSync('/dev/stdin').toString().trim().split('\n');

const [n, m] = rawInputs[0].split(' ').map((v) => +v);
const arr = rawInputs.slice(1).map((v) => v.split('').map((v) => +v));

6,
  6,
  [
    [0, 0, 0, 0, 0, 0],
    [1, 1, 1, 1, 1, 0],
    [0, 1, 0, 0, 0, 0],
    [0, 1, 0, 1, 1, 1],
    [0, 1, 0, 0, 1, 1],
    [0, 1, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 0],
  ];
```
