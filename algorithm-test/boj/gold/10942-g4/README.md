[https://www.acmicpc.net/problem/10942](https://www.acmicpc.net/problem/10942)

백준 10942-g4-팰린드롬 DP

# 느낀 점

DP로 풀 때 배열을 시작 인데스 초기화하는 부분에서 실수했다.

dp[0]부터 초기화할 건지 dp[1]부터 할 건지 헷갈리지 않게 잘 생각해야겠다.

# 문제 읽기

자연수 N개, 질문을 총 M번

각 질문은 두 정수 S와 E(1 ≤ S ≤ E ≤ N)로 나타낼 수 있다

- S번째 수부터 E번째 까지 수가 팰린드롬을 이루는지를 물어봄

수열의 크기 (1 ≤ N ≤ 2,000)

N: 100,000

M (1 ≤ M ≤ 1,000,000)

# 1트: 45분

목표: dp[s][e] 로 접근했을 때 0인지 1인지 바로 알 수 있게 하기

이중 for문으로 s와 e를 1씩 증가시킬 때, (시간복잡도 n ^ 2)

- s ≤ e 이므로, dp[s][e]가 될 수 있는 방법은 dp[s-1][e]와 dp[s][e-1]이 있음
- s === e ⇒ dp[s][e] = 1

그런데 이전값들이 팰린드롬인지 아닌지의 여부가 현재 판단하고자하는 값을 알려주지 않음.

구체적인 숫자가 있어야 판단가능함

ex) 121 → 1211 x , 111 → 1111 o , 111 → 112 x, 1222221 → x, 1222222 →

# 2트: 60m

질문하나에 대해서 s ~ e 가 팰린드롬인지 확인하는 방법

- while(s < e): arr[s] arr[e]를 비교하며 같으면 s++, e—

![풀이](./%ED%92%80%EC%9D%B4.jpeg)

테스트 케이스를 보면

- s === e ⇒ 팰린드롬
- s > e ⇒ 탐색 불가 : 필랜드롬 아님
- s < e ⇒ 탐색 가능:
  - s: e가 팰린드롬이면 s+ 1: e -1도 팰린드롬

`dp[s][e] = dp[s+1][e -1] && arr[s] === arr[e]`

- 그냥 s+1, e -1하면 안 됨
  - dp[2][3] ⇒ dp[3][2] 처럼 반대가 되버림
  - `차이가 2 이상`일 때만
- s를 반대로 탐색해야함
