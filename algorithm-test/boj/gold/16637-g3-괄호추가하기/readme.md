링크: [https://www.acmicpc.net/problem/16637](https://www.acmicpc.net/problem/16637)

[백준] 16637-g3-괄호추가하기 브루스포스

# 느낀 점

스택이나 재귀로 괄호 연산을 미리 해야한다고 생각했다. 그런데 문제 조건 중 “괄호 안에는 연산자가 하나만 들어 있어야 한다”와 “중첩된 괄호 사용할 수 없다”라는 규칙이 있다보니 선형탐색으로 쉽게 해결할 수 있었다.

# 문제 읽기

길이가 N인 수식(1 ≤ N ≤ 19)

- 0보다 크거나 같고, 9보다 작거나 같은 정수
- 연산자: +, -, \*
- 연산자 우선순위 동일 → 왼쪽에서 순서대로 계산

괄호

- 괄호 안에 있는 식 먼저 계산
- 괄호 안에는 연산자가 하나만 들어 있어야 한다
- 중첩된 괄호 사용할 수 없음

괄호를 적절히 추가해 만들 수 있는 식의 결과의 최댓값을 구하는 프로그램

## 1트: 37m

길이가 n인 수식에서 괄호가 들어갈 수 있는 경우의 수

- 괄호가 들어갈 수 있는 공간: n+1
- 괄호가 열리면 닫히 괄호가 와야함

```tsx
앞에서 부터 괄호 치거나 안치거나
만들어지는 식을 계산
끝에 도달하면 최댓값 비교
```

스택?

```tsx
// 괄호가 없는 상황에서
연산 저장
if(target === 숫자)
	if(연산저장) 스택에 숫자 넣기 return
	스택에서 하나 빼기
	연산결과 = 연산(뺀 값, target)
	스택에 연산결과 넣기
  연산저장 초기화
if(target === 연산)
	연산 저장 = target

// 괄호가 있는 상황에서
```

(3 + 8 \* 7)

3 + ( 8 \* 7)

(3 + 8 )\* 7

## 2트: 27m

DFS, 백트래킹

```tsx
// 괄호가 없는 상황에서
if (target === 숫자) return dfs(idx + 1, acc);

if (target === 연산) res = 연산(acc, arr[idx + 1]);
return dfs(idx + 2, res);

// 괄호가 있는 상황에서
if (target === 숫자) return dfs(idx + 1, target);

if (target === 연산) res = 연산(acc, arr[idx + 1]);
return dfs(idx + 2, res);
```

## 3트: 37m

괄호 안에는 연산자가 하나만 존재 ⇒ 3개 단위로 묶임

```tsx
if(target === 숫자)
	dfs(idx+1, target)
if(target === 연산)
  if(idx + 2 < n) // 괄호로 묶기
		a = arr[idx+1]
		b = arr[idx+3]
		다음연산 = arr[idx]
		next = 다음연산(a,b)
		dfs(idx + 4, 연산(acc,next))
	 // 괄호 묶지 않기
		next = arr[idx+1]
		dfs(idx + 2, 연산(acc,next)

```
