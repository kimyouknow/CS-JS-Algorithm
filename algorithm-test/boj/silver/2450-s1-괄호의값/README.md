링크: [https://www.acmicpc.net/problem/2504](https://www.acmicpc.net/problem/2504)

[백준] 2540 s1 괄호의 값 스택

# 느낀 점

스택을 활용하는 까다로운 문제다. [ [ ] ] 혹은 ( [ ] )와 같이 중복될 경우 곱셉연산을 처리해야하는 부분이 까다로웠다. temp라는 중간처리 값을 활용하고 stack에 넣어야하겠다는 생각을 하긴 했지만 temp 값을 처리하는 로직을 생각하는게 쉽지 않았다.

결국 다른 사람 풀이에서 힌트를 얻어서 풀긴 풀었지만, 힌트를 통해 아이디어를 떠올려도 구현하는게 쉽지 않았다. (연산을 미리 풀어서 계산한다는 아이디어)

# 문제 읽기

1≤ input.length ≤ 30

4개의 기호 (, ), [, ]

올바른 괄호열

- 한 쌍의 기호로 이루어짐 (), []
- X가 올바른 문자열이면 (X), [X] 도 인정
- x,y가 올바른 문자열이면 xy도 인정

괄호열 열 계산

- (): 2
- [] : 3
- ( x) : 2 \* x
- [x] : 3 \* x
- xy = x + y

# 1트: 30m

시간복잡도

공간복잡도

예시: (()[[]])([])

i: 주어진 input을 탐색

i = 0 을 우선 stack에 넣고 시작

i = 1부터 탐색 : target = arr[i]

stack의 마지막 값과 target을 비교

중복연산 처리 ⇒ ?

# 2트: 30m: 블로그 힌트 ✅

중복 연산을 미리 계산하기

만약 ( ( 의 경우일 때, 마지막이 ) ) 형태여서 올바르게 닫힌다고 하면, 연산을 분배할 수 있음. 예제를 보면

( () [ [] ] ) ⇒ ( 2 + (9 _ 2)) _ 2 ⇒ 2 _ 2 + 3 _ 3 \* 2

target === (

- temp \* 2
- stack.push(”(”)

target === )

- last === (
  - answer += temp;
  - temp / 2
  - stack.pop()
- last !== ( : 이미 전에 괄호가 닫힌 경우
  - temp / 2
  - stack.pop()

target === [

- temp \* 3
- stack.push(”[”)

target === ]

- last === [
  - answer += temp;
  - temp / 3
  - stack.pop()
- last !== ( : 이미 전에 괄호가 닫힌 경우
  - temp / 3
  - stack.pop()
