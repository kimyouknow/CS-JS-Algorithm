링크: [https://www.acmicpc.net/problem/1932](https://www.acmicpc.net/problem/1932)

[백준] 1932-s1-정수삼각형 다이나믹프로그래밍

# 느낀 점

누적 최대값을 알 수 있는 경로가 아닌 해당 누적 최대값을 구하기 때문에 합을 계산할 때마다 정답으로 제출할 변수를 최대값과 비교하면 된다.

# 문제 읽기

맨 위층부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램

아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.

# 1트: 60m

### d[k] = k층까지 도달했을 때 합의 최대

단순하게 k+1층의 대각선 범위 안의 숫자 중 가장 큰 숫자를 그리디하게 탐색하면 안 됨

반례

- 7
- 1 8
- 1 3 1 3
- 15 2 3 1 1 3 1 3
- 출력: 7 → 8 → 3 → 3 : 21
- 답: 7 → 1 → 1 → 15 : 24

필요한 기준들

- 누적 최대합
- k+1을 구할 때, k층에서 선택된 값의 인덱스

### k+1층으로가면서 합을 구하기

- 7
- 1 8
- 1 3 1
- 15 2 3 1

⇒

- 7
- (1,7) (8,7)

if i === 0

dp[k][i] = dp[k-1][i]

if i === arr[k].length

dp[k][i] = dp[k-1][i-1] + arr[i]

else

dp[k][i] = Math.max(dp[k-1][i], dp[k-1][i-1]]) + arr[i]

# 2트: 실패

삼각형 및 dp를 하나의 배열로 사용하기

total = 전체 길이

7 / 1 8 / 1 3 1 / 15 2 3 1

0 1 2 3 4 5 6 7 8 9

각층의 숫자 개수는 1 2 3 4 5 6 … 로 증가

dp[0] = arr[0]

dp[1] = arr[1] + dp[0]

for(i = 3; i < total; i++)
