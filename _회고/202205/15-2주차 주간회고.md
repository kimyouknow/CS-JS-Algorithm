# 5월 2주차 주간회고

# 코드 스쿼드

> useCallback, useMemo, React.memo, Context API, useReducer, msw

## react 최적화

useCallback이나 useMemo, React.memo 등 최적화 관련된 react 기술들에 대해서 잘못알고 있는 부분이 많았다. 다행이 코드스쿼드 리뷰어분이 학습에 필요한 좋은 키워드들을 많이 알려주셔서 이번 기회에 잘못 알고 있는 사실을 바로 잡을 수 있었다.

## 상태관리

프론트에서 상태관리를 어떻게 할까? 이전까지는 프론트에서 관리할 상태만 고려했는데 프론트의 역할을 고려해보니 백 서버에 있는 데이터도 고려해야 한다는 사실을 알았다. 프론트는 백 서버에 있는 데이터를 사용자에게 적절하게 보여주고 그러기 위해 적절하게 동기화해야 한다.

여러 글에서 redux를 쓸 때, 서버에 데이터를 요청하는 부분을 제거하고 프론트에서 사용하는 로컬 상태만 관리할 수 있게 분리하려는 시도가 많이 보였는데, 그 이유를 알 것 같다. redux가 서버 데이터를 포함한 모든 상태를 관리하는 로직(요청작업)이다기보다 프론트의 로컬 상태관리를 위한 기술이어서가 아닐까?

이번 자판기 미션에서 context api와useReducer를 조합해 react-redux처럼 사용하고 있다. `context api와 useReducer 조합은 reducer, type, action 등 구조는 비슷하지만 최적화와 관련해서 단점이 있다고 한다`. 기능 구현을 다하고 나면 react-redux와 비교해봐야겠다.

## msw

postman-mock-server의 한 달 무료 요청 횟수에 한도가 걸렸다. json-server나 간단한 express 등 여러 가지 모킹둘을 고려하고 있었는데 그러다가 저번에 키워드만 학습했던 msw를 이번 기회에 사용해보기로 했다. `다른 툴에 비해 react폴더 내에서 javascript로 편하게 로직을 구성할 수 있어 편했다.` (req, res)의 형태로 express와 비슷하게 로직을 구성할 수 있어서 편하게 느껴졌다.

# 코넥트

> msw, api설계, 리팩토링

## api 설계

api설계가 계속 바뀌고, api마다 같은 데이터를 다른 변수명으로 선언해 mocking 작업에 어려움을 겪었다.

이전까지 swagger로 api 설계를 관리하고 있었지만 프론트와 백 사이의 api 명세를 관리하는 목적과는 사용목적이 다르다고 생각했다. `swagger는 작성한 코드를 기반으로 로컬에서 보여지기 때문에 백에서 추가적인 작업(api가 변경)이 생기면 브랜치를 최신화되기 전까지 프론트에서 확인할 수 있는 방법이 없었다.`우선 코넥트 노션 페이지에 api설계를 최신화해달라고 요청을 했지만, 노션 페이지도 우리가 직접 커스텀해야하기 때문에 번거롭다고 느껴졌다.

## 리팩토링

기능 구현은 어느정도 마무리가 되어 리팩토링을 진행하려고했다. useFilter, useInfiniteScroll 등 hooks 로직이 재사용성이 떨어지거나, 단순히 로직만 숨겨놓은 것 같은 느낌이 드는 코드가 많았다. 컴포넌트 폴더도 UserCard, TeamCard처럼 비슷한 기능이지만 User와 Team로 분리해 비슷한 구조가 반복되는 컴포넌트들이 많았다. `프로젝트의 완성이 우선이긴하지만 학습을 목적으로 하기 때문에 리팩토링을 조금씩 진행해보려고 한다.`
