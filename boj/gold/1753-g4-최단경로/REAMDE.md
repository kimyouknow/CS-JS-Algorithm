[https://www.acmicpc.net/problem/1753](https://www.acmicpc.net/problem/1753)

[백준] 1753-g4-최단경로 다익스트라, 힙, 우선순위 큐

# 느낀 점

힙과 다익스트라에 대해서 학습할 수 있는 좋은 알고리즘 문제였다.

# 문제 읽기

방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수

정점의 개수 V와 간선의 개수 E가 주어진다. (1 ≤ V ≤ 20,000, 1 ≤ E ≤ 300,000)

1부터 V까지 번호

시작: K(1 ≤ K ≤ V)

셋째 줄부터 E개의 줄에 걸쳐 각 간선을 나타내는 세 개의 정수 (u, v, w)

- u → v: 가중치 w
- u와 v는 서로 다르며 w는 10 이하의 자연수
- 서로 다른 두 정점 사이에 여러 개의 간선

첫째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 정점으로의 최단 경로의 경로값을 출력

# 1트: 28m 시간초과

v+1 \* v +1의 테이블(graph)

dist: v+ 1의 배열 (Infinity로 초기화)

주어진 input배열([u,v,w])을 순회하면서 graph[u].push([v, w])

큐에 넣고 돌리기

queue.push([start, 0])

dist[start] = 0

while

[마지막, 누적가중치] = queue.shift();

if(dist[마지막] < 누적가중치) continue;

for(const [v, w] of graph[마지막])

if (dist[마지막] + w < dist[v])

dist[v] = dist[마지막] + w

queue.push([v, dist[마지막] + w ])

# 2트: 그냥 큐를 쓰면 안되는 이유

**질문 게시판 탐색**

원래 다익스트라 알고리즘은 모두 우선순위 큐에 넣어놓고 거리가 갱신될 때마다 값만 수정한 뒤에, 그 때까지 최소거리인 정점을 pop하고 그 정점까지의 거리를 확정짓는 방식이다. 이 코드상으로는 큐에 여러 번 넣는 것을 막을 장치도 없고, 다만 거리가 최소가 될때까지 무한정 큐에 다시 넣을 수 있으니 결과적으로 올바른 결과가 도출되는 게 아닌가 싶네요.

다만 이 경우 큐에 여러 번 노드가 들어가는 것을 감수해야 하니 그만큼 시간복잡도는 증가한다. 실제로 [백준]1916-g5에서는 같은 로직으로 범위가 작아 성공했다. 더 큰 케이스로 시도하면 시간이 많이 걸린다. 이건 queue를 쓰느냐 priority_queue를 쓰느냐의 문제보다도, "중간에 정점의 거리가 수정될 때 큐에 또 넣느냐 안 넣느냐"의 차이인 것 같아요.

방문처리

익스트라 알고리즘은 우선순위 큐를 써서 거리가 짧은 순으로 방문하기 때문에 한 번 방문한 정점을 다시 방문했을 때 인접한 정점의 거리를 더 짧게 갱신할 가능성이 없고, 다시 방문했을 때는 인접 정점을 순회하지 않아도 괜찮습니다. 이러한 재방문은 최악의 경우 V^2번 연산을 필요로 하게 만들어 시간 초과를 받는 것 같습니다.

# 3트:js로 우선순위 큐 구현
