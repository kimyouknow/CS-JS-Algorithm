링크: [https://www.acmicpc.net/problem/1107](https://www.acmicpc.net/problem/1107)

[백준] 1107-g5-리모컨 브루스포스

# 문제 읽기

리모컨 버튼 : 0 ~ 9 , + , -

+: 현재 채널 + 1

-: 현재 채널 - 1

0에서 채널을 누르면 변하지 않음, 무한대만큼 있음

이동하려고 하는 채널 N (0 ≤ N ≤ 500,000)

고장난 버튼의 개수 M (0 ≤ M ≤ 10)

어떤 버튼이 고장났는지 주어졌을 때, 채널 n으로 이동하기 위해서 버튼을 최소 몇 번 눌러야하는지

현재 보고 있는 채널: 100

# 1트: 52m

숫자를 그대로 누르는 경우, +,-로 이동하는 경우

우선 누를 수 있는 숫자로 탐색하는 수와 최대한 가까운 수를 찾기

최대한 가까운 수부터 +,-로 이동

현재: 000,100

이동해야하는 채널 -1 -1 -1 -1 -1 -1

숫자 배열: [0 ~ 9]: 길이가 10인 bool배열

- true: 이용 가능, false : 고장

고장난 숫자 false처리

이동해야하는 채널을 for문

- -1이면 패스
- 현재 이동해야하는 숫자가 고장난 숫자면 가장 가까운 고장나지 않은 숫자를 찾기
- 현재 이동해야하는 숫자가 고장난 숫자가 아니면 그대로 사용

1번: 5457 / 678

- 5455 ++

2번: 500,000 / 0 2 3 4 6 7 8 9

- 5

문제점

- 100에 가까운 수를 탐색할 때 문제가 발생
  - n = 103, , m = 9

## 2트: 다른 사람 풀이 참고: 58m

cur: 100

targets: n

버튼 배열: Array(10): true → 고장났으면 false로 변경

문제 상황

- 100에 가까운 수일 때,
- 100보다 작은 값은 비슷한 숫자를 큰 값부터 찾아야함
- 100보다 큰 값은 비슷한 숫자를 작은 값부터 찾아야함

비교해야하는 방향

- n === 100
- chanels: Array(1,000,001) : `이동하려는 채널보다 높은 위치에 있을 때 감소하는 범위도 생각해`
- chanels를 하나씩 탐색하면서 고장난 버튼을 포함하면 false로 변경
- chanelds[100] = true

targets로부터 버튼으로 만들 수 있는 가장 가까운 채널 탐색

- n보다 작은 채널 (for (n ≥ i ≥ 0) )
- n보다 큰 채널 (for( n ≤ i < n + abs(n-100))

각 채널 ㅣㅂ교

- 작은 채널: abs(result - n ) + result의 길이
- 큰채널 abs(res - n) + res의 길이
- 100에서 그냥 누르는 경우 abs(100-n)

70,000 / 7,9

66,666 (5) → 70,000(3,334) : 3,339

8

103 / 0,1,2,3,4,5

109/ 1,0,9

95 / 5,9

86

### 참고

- [https://hagisilecoding.tistory.com/39](https://hagisilecoding.tistory.com/39)
- [https://seol-limit.tistory.com/48](https://seol-limit.tistory.com/48)
