링크: [https://www.acmicpc.net/problem/2493](https://www.acmicpc.net/problem/2493)

[백준] 2493 g5 탑 스택

# 느낀 점

문제 분류가 스택인걸 모르고 풀었으면 1트에서 떠올린 아이디어를 떠올리지 못했을 것 같다. 1트에서 스택 유형이라는 걸 알고, 레이저가 한 방향(오 → 왼)으로 동작하는 걸 토대로 반대로 탐색하면서 스택으로 풀 생각을 했다.

2트에서 다시 풀어보니 앞에서부터 탐색하는 것도 가능했다.

정방향이든 역방향이든 `좌측탑이 현재 탐색하고 있는 탑보다 작다보면 비교할 필요 없다. 현재 탑보다 큰 탑이 있을 때가지 좌측으로 이동해야한다는 규칙`이 중요하다!

# 문제 읽기

N은 1 이상 500,000 이하

탑들의 높이는 1 이상 100,000,000 이하의 정수

N개의 높이가 서로 다른 탑을 수평 직선의 왼쪽부터 오른쪽 방향대로 차례대로 세움

탑 꼭대기의레이저 송신기 : 레이저 신호를 지표면과 평행하게 수평 직선의 왼쪽 방향으로 발사

탑의 기둥 모두에는 레이저 신호를 수신하는 장치 있음

하나의 탑에서 발사된 레이저 신호는 가장 먼저 만나는 탑에만 수신 가

탑들의 개수 N과 탑들의 높이가 주어질 때, 각각의 탑에서 발사한 레이저 신호를 어느 탑에서 수신하는지를 알아내는 프로그램을 작성하라.

# 1트: 28✅

반대로 탐색:

- 반대(오 → 왼)부터 탐색해서 현재 가리키고 있는 값과 스택의 마지막 요소를 비교
  - 현재 가리키고 있는 값이 스택의 마지막 요소보다 작다면 (ex: 1 4 인상황에서 스택에 4가 있고 현재 1을 가리키고 있음) 스택에 1을 넣기 (4로 1을 레이저로 맞출 수 없으니까)
  - 현재 가리키고 있는 값이 스택의 마지막 요소보다 크다면 (ex: 5 1 4 인 상황에서 스택에 4 1, 현재 5를 가리키고 있음 ) 스택을 비우면서 답을 채우기 (4와 1로 5를 맞출 수 있으니까)

stack에는 원본 배열 요소의 인덱스 담기

i = n -1

target = arr[i] : 현재 가리키고 있는 값

arr[stack(-1)] > target

- stack.push(i)
- i —

arr[stack(-1)] ≤ target

- ans[stack(-1)] = i;
- stack.pop();

# 2트: 11m✅

앞에서 탐색

stack에는 원본 배열 요소의 인덱스 담기

i = 0

targe = arr[i] 현재 가리키고 있는 값

last = stack[-1]

arr[last] < target

- stack.pop();

arr[last]] ≥ target

- answer[i] = last
- stack.push(i)
- i++
