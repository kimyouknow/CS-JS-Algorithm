링크:[https://www.acmicpc.net/problem/17140](https://www.acmicpc.net/problem/17140)

[백준] 17140-g4-이차원 배열과 연산

# 느낀 점

탐색 범위의 최대 범위가 있고, 실행 최대 수도 100번으로 정해져있기 때문에 시간복잡도를 크게 고려하지 않고 구현위주로 풀어봤다.

매번 탐색할 때마다 행의 최대길이와 열의 최대길이를 리셋해야한다.

# 문제 읽기

크기가 3×3인 배열 A

- 배열의 인덱스는 1부터 시작한다.
- 1초가 지날때마다 배열에 연산이 적용

R연산: 배열 A의 모든 행에 대해서 정렬 : 행의 개수 ≥ 열의 개수인 경우 적용

C연산: 배열 A의 모든 열에 대해서 정렬: 행의 개수 < 열의 개수

정렬 규칙

- 각각의 수가 몇 번 나왔는지 알아야함
- 수의 등장 횟수가 커지는 순으로, 등장 횟수가 같다면 수가 커지는 순으로 정렬
- 다시 배열에 넣을 때는 수와 등장 횟수를 모두 넣는다. (수, 등장횟수)
- 행 또는 열의 크기가 커진 곳에는 0이 채워진다. 수를 정렬할 때 0은 무시
- 행 또는 열의 크기가 100을 넘어가는 경우에는 처음 100개를 제외한 나머지는 버린다.

배열 A에 들어있는 수와 r, c, k가 주어졌을 때, A[r][c]에 들어있는 값이 k가 되기 위한 최소 시간을 구해보자.

A[r][c] = k

# 1트: 61m

시간복잡도

최대 100번 반복 _ c연산이든 r연산이든 최대 100 _ 100탐색

### 이해

100번 실행

배열 100 \* 100으로 초기화

A[r-1][c-1] = k인지

R연산 혹은 C연산 할 때마다 행의 최대 길이와 열의 최대길이를 변수로 따로 지정

정렬: 인덱스로 접근해서 변경해야함

- r방문 객체 만들기 {수: 등장횟수}
- 기준 배열의 인덱스를 하나씩 증가시키면서 탐색
- 새로운 배열: 등장횟수를 기준으로 오름차순 정렬, 등장횟수가 같다면 수를 기준으로 오름차순
- 다시 인덱스를 접근하면서 새로운 배열로 초기화,
- 새로운 배열의 길이가 넘으면 0으로 초기화
