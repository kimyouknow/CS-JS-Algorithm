링크: [https://www.acmicpc.net/problem/16987](https://www.acmicpc.net/problem/16987)

[백준] 16987-g5-계란으로바위치기 백트래킹 완전탐색

# 느낀 점

문제 조건에 맞는 최대값을 구하기위해 완전 탐색할 생각을 쉽게 떠올리지 못했다. 어떻게든 정렬하던가, O(n) 탐색을 하면서 매 탐색마다 최적의 값을 구할 수 있을 줄 알았는데 그러지 못했다.

# 문제 읽기

계란의 수 N(1 ≤ N ≤ 8)

- 내구도 Si (1 ≤ Si  ≤ 300)
- 무게 Wi (1 ≤ Wi  ≤ 300)

계란으로 계란을 치면 `각 계란의 내구도는 상대 계란의 무게만큼 깎임`

내구도가 0 이하가 되는 순간 계란이 깨짐

규칙

- 일렬로 놓여있는 계란에 대해 왼쪽부터 차례로 들어서 한 번씩만 다른 계란을 쳐 최대한 많은 계란 깨기
- 1번: 가장 왼쪽 계란 들기
- 2번: 손에 들고 있는 계란으로 꺠지지 않은 다른 계란 중 하나를 친다.
  - 단, 손에 든 계란이 깨졌거나 깨지지 않은 다른 계란이 없으면 치지 않고 넘어간다.
  - 이후 손에 든 계란을 원래 자리에 내려놓고 3번 과정을 진행한다.
- 3번: 가장 최근에 든 계란의 한 칸 오른쪽 꼐란을 들고 2번 과정 진행.
  - 가장 최근에 든 계란이 가장 오른쪽에 위치한 계란일 경우 계란을 치는 과정을 종료

# 1트: 62m

최대개수

- 한 번 선택한 계란은 다시 선택할 수 없으니까 선택한 계란으로 최대한 많이 깨기
- 어떤 경우가 최대인지 알 수 없으니까 모든 경우를 다 탐색해야한다.

언제 넘어가고

- 모든 계란을 다 돌아보면서, 칠 수 있는 계란이 있으면 치기
- 칠 수 있는 계란이 없으면 dfs 종료

dfs(idx = 현재 들고 있는 계란)

if(idx ≥ n) 종료

if( 현재 계란의 내구도 ≤ 0) dfs(idx+1)

else (현재 계란의 내구도 > 0)

flag = false( 칠 수 있는 계란이 있으면 true로 변경)

for( 0 ≤ j < n)

if(idx === j || j번째 계란의 내구도 ≤ 0) continue

현재 계란 내구도 감소

flag = true

현재 계란 내구도 복구 (모든 경우의 수를 탐색해야하니까)

for문을 다 돌았는데, flag가 flase면 깰 수 있는 계란이 없으니까 다음 계란으로 이동
