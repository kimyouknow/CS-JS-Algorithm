# System Structure & Program Execution

## 핵심 질문

<details>
<summary>Mode bit의 역할은?</summary>
cpu에서 실행되는 것이 운영체제인지 사용자 프로그램인지 구분해준다. 이러한 구분을 통해 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 한다. 사용자 프로그램이 실행되고 있다가 I/O를 해야 하는 상황이 오면 사용자  mode bit가 1로 설정되어 있어 접근이 불가능하기 때문에 바로 OS로 주소 점프를 할 수 없다.
</details>

<details>
<summary>CPU와 메모리가 프로그램을 실행하는 방법은?</summary>
메인 메모리는 CPU가 직접 접근할 수 있는 기억 장치이다. 프로세스가 실행되려면 프로그램이 메모리에 올라와야 한다.
프로그램 카운터라는 CPU안의 register가 가리키고 있는 Memory에서 명령을 읽어서 실행한다. 하나의 명령을 실행하고 나서 다음 명령을 실행하기 전에 interrupt가 들어왔는지 체크
</details>

<details>
<summary>인터럽트의 역할과 인터럽트가 발생하는 타이밍</summary>
현대의 운영체제는 인터럽트에 의해 구동된다. I/O를 요청할 때는 소프트웨어 인터럽트 수행하고, I/O가 끝났으면 I/O controller가 하드웨어 인터럽트 수행한다. cpu는 하나의 명령을 실행하고 나서 다음 명령을 실행하기 전에 interrupt가 들어왔는지 체크한다. 
</details>

<details>
<summary>CPU작업 흐름의 간단한 요약</summary>
CPU는 단순히 일을 빠르게 처리하는 일꾼, 마음대로 할 수 있는게 아니다. 프로그램 카운터라는 CPU안의 register가 가리키고 있는 Memory에서 명령을 읽어서 실행한다. 하나의 명령을 실행하고 나서 다음 명령을 실행하기 전에 interrupt가 들어왔는지 체크한다.interrupt가 들어왔다면 지금 프로그램카운터가 가리키고 있는 Memory에서 명령(instruction)을 읽어서 수행하는게 아니라 CPU를 누가쓰고 있었든지 상관없이 CPU의 제어권이 운영체제에게 넘어간다.
</details>

<details>
<summary>DMA의 역할은? CPU가 인터럽트를 너무 많이 당하고 있는 게 아닐까?</summary>
I/O 장치가 다양하고 많다보니 `cpu가 너무 많은 interrupt를 받아 비효율적이게 동작`하게 된다. (원친적으로 메모리는 CPU에 의해서만 접근할 수 있는 장치이다. CPU 외의 장치가 메모리의 데이터에 접근하기 위해서는 CPU에게 발생시켜 CPU가 대신 컨트롤러의 로컬 버퍼와 메모리 사이에서 데이터를 옮겨준다.)

작업이 들어왔을 때, CPU에게 인터럽트를 거는데 `CPU가 local buffer에 있는 데이터를 메모리에 카피하는 일이 오버헤드가 크다.` 그래서 `DMA controller가 local buffer에 있는 데이터를 메모리에 카피`를 해준다.
작업이 끝났으면 CPU에게 인터럽트를 한 번만 걸어서 "내가 메모리에 카피까지 했어"라는 보고를 하면, CPU는 자신이 맡은 일에 더 집중할 수 있다.

</details>

<details>
<summary>사용자 프로그램은 어떻게 I/O를 할까?</summary>
사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것을 시스템 콜이라고 한다. 
</details>

<details>
<summary>저장장치의 계층 구조를 크게 분류한다면?</summary>
Primary Stroage와 Secondary Storage로 나눌 수 있다. Primary Storage는 cpu에서 직접 접근할 수 있는 매체를 말한다. 전원이 꺼지면 데이터가 사라지는 휘발성 데이터다. Secondary Storage는 cpu에서 직접 접근할 수 없는 매체를 말한다. 해당 저장소는 전원이 꺼져도 데이터가 보존되는 비휘발성 데이터다.
</details>

<details>
<summary>프로그램은 어떤 과정을 거쳐 실행될까?</summary>
프로그램은 File System에 실행 파일 형태로 저장되어 있고, 이를 실행하면 메모리에 올라가 프로세스가 된다. 정확히 말하면, 물리적인 메모리에 프로그램이 바로 올라가는 것이 아니라 가상 메모리 단계를 추가로 거친다. 이때 독자적인 메모리 주소 공간이 형성되는데, 이 공간에는 Code, Data, Stack 영역이 있다.

</details>

---

운영체제를 본격적으로 학습하기 전 컴퓨터 시스템에서 하드웨어와 프로그램이 하드웨어 위에서 어떻게 돌아가는지 이해하는 챕터

## 흐름 요약

컴퓨터 시스템의 구조는 컴퓨터 내부 장치인 CPU, 메모리와 컴퓨터 외부 장치(I/O)인 디스크, 키보드, 마우스, 모니터, 네트워크 장치 등으로 구분된다. 컴퓨터는 외부장치에서 내부 장치로 데이터를 읽어와 연산을 실행한 후, 그 결과를 외부장치로 내보내는 방식으로 일을 수행한다.

## 컴퓨터 시스템 구조

![컴퓨터 시스템 구조](./image/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B5%AC%EC%A1%B0.png)

> 사진출처: https://hyojaedev.tistory.com/28

### CPU

---

CPU는 단순히 일을 빠르게 처리하는 일꾼, 마음대로 할 수 있는게 아니다. `CPU는 클럭마다 메모리에서 인스트럭션을 하나씩 읽어서 실행하는 역할`을 한다.

`프로그램 카운터라`는 CPU안의 register가 가리키고 있는 Memory에서 명령을 읽어서 실행한다.

하나의 명령을 실행하고 나서 다음 명령을 실행하기 전에 interrupt가 들어왔는지 체크

interrupt가 들어왔다면 지금 프로그램카운터가 가리키고 있는 Memory에서 명령(instruction)을 읽어서 수행하는게 아니라 CPU를 누가쓰고 있었든지 상관없이 CPU의 제어권이 운영체제에게 넘어간다.

> 운영체제 안에는 interrupt상황에 맞게 처리해야할 일들이 커널함수로 정의되어 있다. (인터럽트 백터)
> 정의되어 있는 인터럽트 처리 루틴이 실행한다.

## 접근 범위

CPU는 메인 메모리와 local buffer에 접근이 가능하다.

## [mode bit]

CPU에서 실행되는 것이 운영체제인지 사용자 프로그램인지 구분해주는 것

사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치

- **1 사용자모드 :** 사용자 프로그램이 CPU를 가질 때 제한된 명령만 실행시킬 수 있다.

- **0 모니터모드(커널모드 ,시스템 모드) :** 운영체제가 CPU에서 실행 중일 때는 모든 명령을 실행할 수 있다.

### 실질적인 동작

Interrupt나 Exception 발생시 하드웨어가 mode bit를 0으로 바꾼다.

사용자 프로그램에게 CPU를 넘기기 전에 mode bit를 1로 세팅한다.

## [Interrupt line]

CPU는 메모리와 일하는데 중간에 IO작업이 있을 때 인터럽트 라인에 신호가 들어오면 하던 일을 멈추고 인터럽트와 관련된 일을 처리한다.

### Interrupt

`현대의 운영체제는 인터럽트에 의해 구동된다.`

- I/O를 요청할 때는 소프트웨어 인터럽트 수행
- I/O가 끝났으면 I/O controller가 하드웨어 인터럽트 수행

인터럽트 당한 시점의 레지스터와 프로그램 counter를 저장한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.

#### **넓은 의미**

- 하드웨어 인터럽트: 하드웨어가 발생시킨 인터럽트
- 트랩(Trap): 소프트웨어 인터럽트
  - Exception: 프로그램이 오류를 범한 경우
  - System call: 프로그램이 커널 함수를 호출하는 경우

#### **인터럽트 관련 용어**

인터럽트 백터: 해당 인터럽트의 처리 루틴 주소를 가지고 있다.

인터럽트 처리 루틴 ( = 인터럽트 핸들러) : 해당 인트럽트를 처리하는 커널 함수, 실제 인터럽트를 처리하는 부분

### [레지스터(register)]

CPU 내부에 메모리보다 더 빠르면서 정보를 저장할 수 있는 작은 공간이다.
레지스터 중에 메모리 주소를 가리키는 레지스터인 PC(Program Counter) 레지스터가 있다.
CPU는 PC 레지스터가 가리키는 메모리 위치에서 인스트럭션을 읽어서 수행한다.

## Memory

---

메모리는 CPU가 직접 접근할 수 있는 내부 기억 장치다. 특정 프로그램이 CPU에서 실행되려면 해당 부분이 메모리에 올라가 있어야 한다. 운영 체제는 컴퓨터가 부팅되었을 때 메모리에 올라가 있는데, 메모리에 상주하고 있는 `CPU의 작업 공간`을 Main memory라고 한다.

## I/O 입출력의 수행

---

모든 입출력 명령은 특권 명령

사용자 프로그램은 어떻게 I/O를 하는가?

- **시스템 콜**: 사용자 프로그램은 운영체제에게 I/O를 요청한다.
- 트랩(trap: 소프트웨어 인터럽트)를 사용하여 인터럽트 백터의 특정 위치로 이동
- 제어권이 인터럽트 백터가 가리키는 인터럽트 서비스 루틴으로 이동
- 올바른 I/O요청인지 확인후 I/O 수행
- I/O 완료 시 제어권을 시스템 콜 다음 명령으로 옮김

## I/O device controller

각각의 IO에 붙어, `각각의 I/O 디바이스를 전담하는 작은 CPU 역할`을 한다.

제어 정보를 위해 control register, status register를 가진다.

I/O는 실제 deivce와 local buffer사이에서 일어난다.

[device controller]

- device controller에는 디바이스의 정보를 담기 위한 `local buffer`라는 것이 존재한다. .
- device controller는 I/O가 끝났을 경우 interrupt로 CPU에 그 사실을 알린다.

[registers]

- CPU 내부에 Memory보다 빠른, 정보를 저장할 수 있는 공간

### local buffer

일종의 data register, 각각의 IO에 붙어 있는 작은 Memory. 데이터를 임시로 저장하기 위한 작업 공간이다.

### deivce driver

CPU가 실행하는 각 디바이스에 접근하기 위한 소프트웨어

#### `CPU 대신에 device controller가 전담하는 이유는 무엇인가?`

CPU와 디바이스의 속도 차이가 매우 많이 나기 때문에 CPU가 전담하지 않고 device controller가 전담하게 된다.

#### `device driver & device controller는 무슨 차이인가?`

device driver는 소프트웨어를 뜻하며, CPU가 실행하는 각 디바이스에 접근하기 위한 소프트웨어를 말한다.
device controller는 하드웨어를 뜻하며, 각 장치를 통제하는 일종의 작은 CPU를 말한다.

## timer

---

특정 프로그램이 CPU를 독점하는 것을 막기 위한 장치다. time sharing을 구현하기 위해 사용된다. 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킨다.

### 동작

운영체제가 CPU를 가지고 있다가 특정 사용자 프로그램이 실행되기 위해 해당 프로그램에게 CPU를 넘겨주는데 이 때 timer값도 같이 세팅한다. 프로그램이 실행하다가 세팅된 시간이 되면 timer가 CPU한테 interrupt를 건다.

타이머는 매 클럭 틱 때마다 1씩 감소한다.

## DMA(direct memory access) controller

인터럽트가 많이 당하면, 빠른 장치인 CPU가 효율적이지 않다. 일을 시작하려고 하면 인터럽트가 발생하고 이런 과정이 반복된다면 제대로 일을 하지 못하는 상황이 발생하게 된다. 그래서 해결방안으로 DMA controller를 두고 있다.

DMA controller는 `직접 메모리에 접근할 수 있는 컨트롤러`이다. 원칙적으로 cpu만 메인 메모리에 접근했지만, dma controller도 접근가능하다.

### I/O 장치가 자주 인터럽트를 하니 CPU가 너무 방해받고 있다.

> DMA는 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용한다.

I/O 장치가 다양하고 많다보니 `cpu가 너무 많은 interrupt를 받아 비효율적이게 동작`하게 된다. (원친적으로 메모리는 CPU에 의해서만 접근할 수 있는 장치이다. CPU 외의 장치가 메모리의 데이터에 접근하기 위해서는 CPU에게 발생시켜 CPU가 대신 컨트롤러의 로컬 버퍼와 메모리 사이에서 데이터를 옮겨준다.)

작업이 들어왔을 때, CPU에게 인터럽트를 거는데 `CPU가 local buffer에 있는 데이터를 메모리에 카피하는 일이 오버헤드가 크다.` 그래서 `DMA controller가 local buffer에 있는 데이터를 메모리에 카피`를 해준다.
작업이 끝났으면 CPU에게 인터럽트를 한 번만 걸어서 "내가 메모리에 카피까지 했어"라는 보고를 하면, CPU는 자신이 맡은 일에 더 집중할 수 있다.

DMA를 사용하게 되면 CPU의 중재 없이 device controller가 deivce의 buffer storage의 내용을 메모리에 block단위로 직접 전송할 수 있다. (바이트 단위가 아니라 block단위로 인터럽트를 발생시킨다. )

### CPU와 DMA controller가 메인 메모리에 접근 가능했을 때, 문제점이 있나?

특정 메모리 영역에 동시에 접근할 때 문제점이 발생할 수 있다. 그래서 해결방안으로 `memory controller`가 이를 중재한다. 즉, `교통정리 역할`을 한다.

## 시스템 콜

사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것

![시스템콜](./image/%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%BD%9C.png)

## 동기식 입출력과 비동기식 입출력

---

![동기비동기](./image/%EB%8F%99%EA%B8%B0%EC%8B%A4%EB%B9%84%EB%8F%99%EA%B8%B0%EC%8B%9D.png)

### 동기식 입출력 (synchronous I/O)

I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에게 넘어가낟.

**구현 방법1**

- I/O 끝날 때까지 CPU를 낭비시킨다.
- 매시점 하나의 I/O만 일어날 수 있다.

**구현 방법2**

- I/O가 완료될 때까지 해당 프로그램에서 CPU를 빼앗는다.
- I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움
- 다른 프로그램에게 CPU를 준다.

### 비동기식 입출력 (asynchronous I/O)

I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에게 즉시 넘어간다.

CF> 두 경우 모두 I/O의 완료는 인터럽트를 통해 알려준다.

## 서로 다른 입출력 명령어

![서로다른입출력명령어](./image/%EC%84%9C%EB%A1%9C%EB%8B%A4%EB%A5%B8%EC%9E%85%EC%B6%9C%EB%A0%A5.png)

### I/O를 수행하는 special instruction에 의해

memory에 접근하는 instuction과 Deivce Instruction을 구분한다. I/O를 위한 별도의 instructiuon을 만든다.

### MemoryMapperd I/O에 의해

I/O도 memory의 연장주소를 붙혀서 관리한다. 예를 들어, 100번 접근하는 것이 일반 메모리에 접근하는 것이고, 2,000번에 접근하는 것이 I/O에 접근하는 것이라고 지정한다.

## 저장장치 계층 구조

![저장장치계층구조](./image/%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98%EA%B3%84%EC%B8%B5%EA%B5%AC%EC%A1%B0.png)

위로 갈수록 속도가 빠르지만, 단위 공간 당 가격이 비싸고 용량이 적다.

CPU는 바이트 단위로 접근 가능한 매체이어야 접근이 가능하다.

### Prmiary Storage

CPU에서 직접 접근할 수 있는 매체를 말한다. 해당 스토리지는 바이트 단위로 CPU 접근이 가능히므로 Primary라고 부른다.

전원이 꺼지면 데이터가 사라진다. (휘발성)

### Cache Memory

CPU와 메인 메모리의 속도 차이를 줄여주기 위해 존재한다. 용량이 적기 때문에 모든 것을 담아 둘 수는 없지만, 자주 사용되는 필요한 정보를 선별적으로 저장하여 재사용하는 캐싱 기법을 통해 시스템의 성능을 높힐 수 있다.

### Secondary Storage

CPU에서 직접 접근하지 못하는 매체를 말한다. 하드 디스크의 단위는 섹터이므로 CPU가 접근하지 못해서 Secondary라고 부른다.

해당 저장소는 전원이 꺼져도 데이터가 보존된다. (비휘발성)

## 프로그램의 실행 (메모리 load)

---

![메모리load](./image/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98%20%EC%8B%A4%ED%96%89-%EB%A9%94%EB%AA%A8%EB%A6%AC.png)

프로그램은 `File System에 실행 파일 형태로 저장`되어 있고, 이를 `실행하면 메모리에 올라가 프로세스`가 된다.

정확히 말하면, 물리적인 메모리에 프로그램이 바로 올라가는 것이 아니라 `가상 메모리 단계`를 추가로 거친다. 이때 `독자적인 메모리 주소 공간`이 형성되는데, 이 공간에는 `Code, Data, Stack` 영역이 있다.

### Code

CPU에서 실행할 기계어 코드를 저장한다.

### Data

전역 변수 등 프로그램이 사용하는 데이터를 저장한다.

### Stack

함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장한다. 그 다음 가상 메모리에서 물리적인 메모리로 프로그램이 올라가는데, 메모리 낭비를 방지하기 위해 프로그램 중 당장 실행에 필요한 부분만 올라가고, 그렇지 않은 부분은 디스크 중 메모리의 연장 공간으로 사용되는 `스왑 영역(swap area)`에 내려 놓는다. 즉, 주소 공간을 쪼개서 어떤 부분은 메모리에 있고, 어떤 부분은 스왑 영역에 있게 된다.

### Virtual Memory

사용하지 않으면 메모리에서 쫓아 버리는 게 아니라 Disk에 내려놓게 된다. (이러한 용도의 공간을 Swap area라고 한다)
즉, 주소 공간을 쪼개서 어떤 부분은 메모리에 있고, 어떤 부분은 Swap area에 있게 된다.
이런 기법을 Virtual Memory라고 부르기도 하지만, 사실 각 프로그램마다 독자적으로 가지고 있는 메모리 주소 공간을 Virtual Memory라고 한다.

## 커널 주소 공간의 내용

![커널주소](./image/%EC%BB%A4%EB%84%90%EC%A3%BC%EC%86%8C%EB%82%B4%EC%9A%A9.png)

### Code

CPU, 메모리 등의 효율적으로 자원을 관리하기 위한 부분과 사용자에게 편리한 인터페이스를 제공하기 위한 부분이 주를 이루고 있다. 이 밖에도 커널의 코드는 시스템 콜 및 인터럽트를 처리하기 위한 부분을 포함한다.

### Data

각종 자원을 관리하기 위한 자료 구조가 저장된다. CPU나 메모리와 같은 하드웨어 자원을 관리하기 위한 자료 구조뿐 아니라 프로세스를 관리하기 위한 자료 구조도 커널의 데이터 영역에 유지된다. 커널의 데이터 영역 내에는 각 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등을 유지하기 위한 PCB를 두고 있다.

### Stack

프로그램의 스택 영역과 마찬가지로 함수 호출 시의 복귀 주소를 저장하기 위한 용도로 사용된다. 하지만 커널의 스택은 일반 사용자 프로그램의 스택과 달리 현재 수행 중인 프로세스마다 별도의 스택을 두어 관리한다.

이는 일반 사용자 프로그램이 자기 주소 영역 내부의 함수를 호출하면 자신의 스택에 복귀 주소를 저장하지만, 프로세스가 특권 명령을 수행하려고 커널에 정의된 시스템 콜을 호출하고 시스템 콜 내부에서 다른 함수를 호출하는 경우에는 복귀 주소가 커널 내의 주소가 되므로 커널의 스택 영역에 저장되어야 하기 때문이다.

즉, 프로그램이 자기 자신의 코드 내에서 함수 호출 및 복귀 주소를 유지하기 위해서는 자기 주소 공간 내의 스택을 사용하고, 시스템 콜이나 인터럽트 등으로 운영 체제의 코드가 실행되는 중에 함수 호출이 발생할 경우 커널 스택을 사용한다.

## 사용자 프로그램이 사용하는 함수

---

### 사용자 정의 함수

자신이 프로그램에서 정의한 함수

### 라이브러리 함수

자신의 프로그램에서 정의하지 않고 갖다 쓴 함수

자신의 프로그램의 실행 파일에 포함

⇒ 프로세스의 address space

### 커널 함수

운영체제 프로그램의 함수

커널함수의 호출 = 시스템 콜

⇒ Kernel Address space

## 프로그램의 실행

![프로그램의 실행](./image/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98%20%EC%8B%A4%ED%96%89.png)
