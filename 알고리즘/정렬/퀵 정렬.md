# Quick sort

기준 데이터를 고른 뒤, 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법

가장 기본적인 퀵 정렬은 첫번째 데이터를 기준데이터로 설정 → (1)왼쪽에서 피벗보다 큰 데이터를 고르고, 오른쪽에서 피벗보다 작은 데이터를 고르기 → 서로 위치바꾸기 → 다시 피벗기준으로 (1)을 실행 → 좌우가 엇갈리면 작은 값과 피벗값을 바꾸기 → 그럼 좌우로 피벗기준으로 작은애들, 큰애들로 구분됨 → 재귀실행

시간복잡도: 0(NlogN) 최악의 경우 O(n^2)

> 구체적인 실행 단계

- 하나의 리스트를 피벗(pivot)을 기준으로 두 개의 비균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법이다.
- 퀵 정렬은 다음의 단계들로 이루어진다.

1. 분할(Divide): 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)로 분할한다.
2. 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출 을 이용하여 다시 분할 정복 방법을 적용한다.
3. 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.
4. 순환 호출이 한번 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.

```js
const quickSort = function (arr) {
  if (arr.length <= 1) return arr;

  const pivot = arr[0];
  const left = [];
  const right = [];

  for (let i = 1; i < arr.length; i++) {
    if (arr[i] <= pivot) left.push(arr[i]);
    else right.push(arr[i]);
  }

  const lSorted = quickSort(left);
  const rSorted = quickSort(right);
  return [...lSorted, pivot, ...rSorted];
};
```

# 단점

- 원본 배열 안에서 변경하지 않기 때무에 별도의 메모리 공간이 필요하므로 데이터 양이 많으면 공간적 낭비가 심해질 수 있다.
