# 단위테스트

타입스크립트로 연결리스트를 구현했다. 어떻게 하면 각 단위 테스트들이 독립적이면서, 반복되는 코드를 줄일 수 있을까 고민했다. 중복되는 코드를 줄이다가 단위 테스들의 독립성이 깨지는 경우가 생겼고, 단위 테스트마다 독립적이게 짜다보면 비슷한 코드가 많아졌다.

적절한 방법론이나 아키텍처를 고민해봤지만 떠오르지 않았다. 여러 키워드로 검색해도 마땅한 해결책을 찾지 못했다. 우선 코드를 짜되, **핵심기능을 파악해 유지보수하기 편한 코드를 작성하는 것에 초점**을 두고 진행했다.

연결리스트의 핵심 메서드는 동작하게 했지만 I/O 작업을 마무리 짓지 못했다. nodejs를 활용해 티미널 I/O를 활용할까하다가 DOM조작도 연습하고 싶어 브라우저에서 I/O를 받도록 계획했다. vanilla js를 활용할까하다가 타입스크립트를 활용하고 싶어 별도의 프레임워크 없는 타입스크립트로 브라우저에서 동작하는 코드를 작성하기로 했다.

### 잘한점

- 연결리스트 메서드를 테스트코드와 함께 구현했다.
- 단위 테스트에 대한 고민을 꾸준히 했다.
- 하루에 한시간씩 꾸준히 했다.

### 아쉬운점

- 자료구조에 대한 공부보다는 테스트코드 위주로 공부했다.
- 일주일안에 마무리하려 했지만 I/O 작업을 완료하지 못했다.
- 피드백을 받지 못했다.

# 배포환경공부

개인 프로젝트를 시작하기에 앞서 api문서 작성과 aws를 활용해 배포를 할 계획이었다. 마침 코넥트 프로젝트에서도 배포관련이슈가 있어 api문서를 작성하기 전에 배포관련된 공부를 했다. 학습키워드는 다음과 같다.

```bash
정적사이트, 동적사이트, web server(ws), web application server(was),
aws-ec2, aws-s3, ngninx, github actions, docker, 그 외 다양한 서버이론 공부
```

배포 환경에 대한 공부를 하고나니 내가 만든 프론트 코드가 어떻게 동작하는지 더 깊게 이해할 수 있었다. 계획했던 것보다 오래걸렸는데 아직 절반도 이해하지 못한 것 같아 적절한 수준에서 프로젝트에 적용해야겠다.

### 잘한점

- 배포관련 이론 학습
- CI/CD에 대한 기초 이론 학습
- 키워드 정리로 다른 사람에게 간단히 설명할 수 있을 정도로 학습했다.

### 아쉬운점

- 한 번에 완벽한 구조를 만들려고 욕심을 많이 냈다. 기초부터 하나씩 적용했어야하는 생각이 든다.
- 너무 많은 기술을 적용하려고 했다.

# 댓글컴포넌트 리팩토링

댓글 컴포넌트를 리팩토링하면서 다음과 같은 부분을 신경썼다.

### UI와 로직 분리

하나의 컴포넌트 내부에 UI와 관련된 코드와 로직이 함께 있었다. 댓글을 생성하는 로직은 CommentForm.jsx라는 컴포넌트만 보면 되지만 컴포넌트가 커져서 가독성이 안 좋고, 상위 컴포넌트 및 형재 컴포넌트에 의존적이라 리팩토링이 어려웠다. **Context API를 활용해 props drilling문제를 해결하고 useComment라는 커스텀 hooks를 만들어 로직을 분리했다.**

### 컴포넌트구조

이전에는 `비슷한 구조(스타일, 형태)를 기준으로 컴포넌트를 구분`했다. 예를 들어, form과 관련된 코드가 있다고 하면 형태는 비슷한 댓글 추가, 댓글 수정, 대댓글 추가, 대댓글 수정을 하나의 CommentForm.jsx에서 해결했다. **하나의 컴포넌트가 4가지 일을 담당하다보니 jsx부분에 분기처리가 많아지고, 의존성있는 prop가 많아졌다.**

이후 `데이터와 로직을 기준으로 컴포넌트를 구분`했다. 비슷한 형태라도 내부 데이터 성격이 다르고, 로직이 다르면 별도의 컴포넌트를 만들었다. 위의 예시에서 사용한 CommentForm의 경우, Create.Reply.CommentForm.jsx, Create.Root.CommentForm.jsx, Edit.Reply.CommentForm.jsx, Edit.Root.CommentForm.jsx처럼 별도의 컴포넌트를 만들었다. 스타일 요소가 반복될 것 같지만 하나의 스타일 파일에서 관리해 반복되는 부분을 최소화했다.

### 로컬상태관리와 서버상태관리(+fetch요청) 구분

현재 get요청만 되게 되어있다. axiosinstance를 받아서 사용하지만 hooks의 특성상 callback함수안에서 선언할 수 없고 함수형 컴포넌트 body에 선언해야한다. 그러다보니 기존 코드로 사용자 액션에 의해 발생하는 fetch요청을 수행하기 어려웠다. (post, patch, delete 요청 이후 get요청으로 최신화하는 경우)

이를 해결하기 위해 특정 컴포넌트를 위한 hooks를 별도로 만들어서 관련 fetch요청을 묶었다. 여러 useAxios를 선언하지 않고 하나의 useAxios를 사용하도록 수정했다. 최초 get요청은 props로 선언적으로 처리한 이후 수정/삭제/추가 로직이 있을 때마다 자동으로 get요청이 요청되도록 수정했다.

# 체계화된 백로그 관리 및 회의록, 정리록 및 github 관리 필요성

백앤드와 연결을 제대로 시작하면서 여러 가지 오류가 발생했다. 대부분의 데이터 타입이 api명세와 맞지 않았고, 로그인 흐름, 배포 등등 해결해야할 문제가 너무 많았다.

회의를 하거나 코드를 짜다가 변경사항이 생기면 이야기를 통해 문제를 해결했다. 해결 내용과 과정을 노션에 정리하긴 했지만 나중에 찾아보기 어려웠다. 예를 들어, 비즈니스 로직과 UI가 수정됐을 때 회의록에만 정리하니 특정 키워드로 찾아보기 쉽지 않았다.

스토리를 다시 한 번 정리했다. 이전에 작성해둔 유저 스토리는 프론트만 사용할 수 있는 스토리였다. 백앤드나 디자인과 관련된 내용이 없었고, 핵심적인 로직을 따로 적지 않았다. 전체 프로젝트를 위한 유저 스토리는 다음과 같은 형식으로 정리해봤다.

```markdown
## 핵심 스토리

// 요약

## [비즈니스 로직]

// 공통 비즈니스로직
// 공통 비즈니스로직에 따른 프론트 로직
// 공통 비즈니스로직에 따른 백 로직

## [UI]

// 해당 스토리를 위해 필요한 UI
```

당장 프론트코드도 잘 작성하지 못하는데 너무 기획에 힘을 주고 있는 건 아닐까 고민이 들었다. 하지만 **프로젝트를 진행하면서 중구난방으로 할 일을 관리하는 것보다 잘 정리된 틀안에서 작업해야 유지보수하기 수월할 것 같다**는 생각이 들었다.
