# 20220712

<details>
<summary>시간대별 정리</summary>

### 아침

회고작성

eo- 27년자 실리콘 밸리..

### 오전

자바스크립트 모듈 공부

export default vs export

### 오후

자바스크립트 모듈 공부 깊은 이해

babel

typescript babel nodemon 세팅 학습

### 저녁

코넥트

- 댓글 CRUD api요청 이후 업데이트 로직 수정 고려

</details>
<br>

# 개인공부

typescript + express + jest 세팅해서 TDD를 학습했다.

jest를 사용해 mocking하던 도중 다음과 같은 문제가 발생했다. import문을 사용할 땐, 원하는대로 동작하지 않지만 module을 사용하니까 원하는대로 동작했다.

여러 자료들을 참고하면서 문제를 해결하던 도중 내가 무엇을 이해하지 못했나 찾아보고 키워드 별로 학습했다.

## jest module/fn mocking

**mocking이란? :** 단위 테스트를 작성할 때, 해당 코드가 의존하는 부분을 가짜(mock)로 대체하는 기법

`단위테스트`는 `독립적`이어야하며, 어떤 테스트도 다른 테스트에 `의존하지 않아야 한다`. 독립적이기 위해선 `외부 모듈과 로직에서 분리`되어야 하기 때문에 Ajax, Fetch, DB 등 테스트 대상이 의존하는 것을 다른 것으로 대체해야한다.

Jest에서 모듈과 함수를 Mocking 하는 3가지 방법이 있다.

- `jest.fn`: Mock a function
- `jest.mock`: Mock a module
- `jest.spyOn`: Spy or mock a function

## 자바스크립트 모듈과 babel

nodejs를 공부하다보니 require문을 자주 보게되었다. 나는 브라우저에서 동작하는 코드를 많이 작성하던 편이어서 es6를 주로 사용했다. (es모듈은 자바스크립트 표준화된 모듈 시스템으로 브라우저에서 지원한다.)

nodejs도 버전 13.2부터 es모듈 시스템에 대한 정식 지원을 시작했지만, 파일 확장자를 `mjs`로 바꾸거나 packge.json의 최상위 `type을 module`로 설정해야한다. 하지만 `es6 이상의 최신 자바스크립트 문법`으로 작성된 코드가 nodejs에서 실행되지 않은 경우가 종종 있어 `babel`을 활용하여 개발을 주로 하고 있다.

모듈 시스템이 익숙해서 사용하고 있지만 es모듈이 어떻게 동작하는지 이해해본적은 없어 이번 기회에 정리했다. 또한 babel 어떻게 동작하는지 찾아봤다.

**모듈이란? :** 단지 파일 하나를 의미한다. 스크립트 하나는 모듈 하나라고 할 수 있다.

**ES 모듈의 동작 방식 :** es6모듈의 경우 구성 → 인스턴스화 → 평가 3단계를 거쳐 진행된다.

**Babel**: ES6+ 버전 이상의 자바스크립트나 JSX, 타입스크립트 코드를 하위 버전의 자바스크립트 코드로 변환 시켜 IE나 다른 브라우저에서 동작할 수 있도록 하는 역할을 한다.

## babel vs typescript

여러 글을 찾아본 결과 TypeScript 컴파일러와 Babel은 모두 고유한 처리 방식을 가지고 있다. 따라서 소개하는 글 마다 다양한 의견이 있으며 어느 하나가 좋다고 느끼기엔 아직 어려운 부분이 많다. 우선 옵션에 대한 간략한 이해와 어떤 툴을 사용할지보다 컴파일러의 역할에 대해 이해할 필요가 있어 보인다.

**ts-node** :

- Node.js 상에서 TypeScript Compiler를 통하지 않고도, 직접 TypeScript를 실행시키는 역할
- 대표적인 기능: 자동 tsconfig.json 구문 분석, 노드 버전과 자동으로 일치, Typechecking (optional), 기본 ESM 로더, 테스트 실행기, 디버거 및 CLI 도구와 통합 등등

**babel with @babel/preset-typescript**

- 바벨을 활용해 ts를 컴파일

결론적으로 @babel-node + @babel/preset-typescript가 아닌 `ts-node`를 선택했다. 그 이유는 다음과 같다.

- ts-node는 모든 TypeScript 언어 기능을 지원하지만 @babel/preset-typescript는 네임스페이스 및 인라인 모듈을 지원하지 않는다.
- ts-node는 @babel/preset-typescript(예: @babel/plugin-proposal-object-rest-spread) 위에 추가 babel 플러그인이 필요한 다양한 Ecmascript 언어 기능을 즉시 지원한다.
- ts-node는 변환하는 동안 유형 검사를 수행할 수 있지만 @babel/preset-typescript는 유형 정보만 제거하고 입력을 별도로 확인해야 한다.

# 코넥트

### (대)댓글 CRUD api요청 이후 업데이트 로직 수정 고려

아래 로직 중 3번과 같이 (대)댓글 관련 로직이 구현했었다. 하지만 생각해보니 기존 로직은 여러 클라이언트에서 동시에 추가/수정/삭제 요청이 일어날 때 특정 클라이언트에서 적절하게 반영하기 어렵기도 하고, 프론트에서 별도의 로컬 데이터를 최신화 로직이 필요하다는 단점이 있다.

댓글 컴포넌트를 다시 렌더링하는데 얼마나 비용이 발생하는지 정량적인 비교는 해보지 않았지만 코드스쿼드 미션을 하면서 1번 로직이 적절하다고 생각해 1번 로직으로 변경했다.

✅ 1. **추가/수정/삭제 요청 → 서버에서 성공 메세지 받기 (별도의 데이터는 받지 않음) → 다시 get 요청해서 목록 전체 받기**

장점

- 프론트에서 로컬 데이터를 최신화 로직을 줄일 수 있다.
- 서버상태를 확실하게 반영할 수 있다.
  단점
- 하나의 액션에 네트워크 요청이 두 번 필요하게 됨.

1. **추가/수정/삭제 요청 → 해당요청의 응답으로 최신화된 목록 전체 받기**

   장점:

   - 프론트 로직이 줄어들고
   - 서버상태를 확실하게 반영할 수 있다.

   단점:

   - 상태를 다 바꿔서 모두 렌더링
   - put, patch, post 요청인데 response로 전체 목록을 받는게 이상하다.

**3. 추가/수정/삭제 요청 → 서버에서 바뀐 데이터 값만 전달 → 프론트에서 바뀐 데이터를 골라서 반영**

장점

- 한번의 요청으로 해결 가능
- 모든 UI를 리렌더링할 필요 없이 바뀐 부분만 리렌더링하면 된다.

단점

- 프론트에서 별도의 업데이트 로직을 구현해야함
- 여러 클라이언트에서 동시에 추가/수정/삭제 요청이 일어날 때 특정 클라이언트에서 적절하게 반영하기 어렵다.
