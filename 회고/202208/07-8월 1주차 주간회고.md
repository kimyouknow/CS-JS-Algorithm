이번 주를 되돌아보니 내가 7월 한 달간 반복하던 잘못된 부분을 알 수 있었다.

### 이것 저것 한 번에 너무 많이 하려고 했다.

오전에는 cs학습이나 알고리즘을 풀고 오후엔 토이 프로젝트를 하고 저녁엔 코넥트 스터디를 했다. 복학하기 전까지 토이 프로젝트로 express 서버도 tdd로 만들어보고, 프론트도 테스트코드와 스토리 북을 적용하려고 했고, CI/CD까지 하려고 했다. 한 번에 모든 걸 하려다보니 깊이 있는 학습을 하지 못하고 문제 해결을 위한 구글링 시간만 늘었다.

그렇다고 새로운 걸 구현하는게 아니라 비슷한 수준의 문제만 해결하니 흔히 말하는 `Confort Zome`에서 놀고 있다는 생각이 들었다. 계획된 일을 좀 줄이더라도 몇 가지 일만 선택해 집중하는 시간을 가져야겠다.

# 코넥트

### 개발과정에서 병목현상 및 반복

개발을 하면서 요구사항이 계속 바뀌다보니 했던 작업을 3,4번 씩하고 있다.

### 서버 상태 반영을 위한 CRUD / 상태관리 / UI 분리

이전 댓글 컴포넌트는 하나의 컴포넌트에서 UI를 렌더링하고, 로컬 상태를 관리하고, 서버 상태를 위한 api요청이 이뤄졌다. 컴포넌트의 수는 적지만 컴포넌트 하나하나가 많은 기능을 담당해 비대해졌다.

또한, 컴포넌트를 UI의 관점에서 분리하다보니 컴포넌의 수는 적더라도 컴포넌트 내 분기처리해야하는 코드가 많아졌다. 댓글form컴포넌트에는 댓글 작성, 댓글 수정, 대댓글 작성, 대댓글 수정이라는 4 가지 기능이 있었고, 댓글목록 컴포넌트에는 댓글목록과 대댓글목록을 재귀를 통해 해결했었다.

당연하게도 몇몇의 거대한 컴포넌트끼리 상호작용을 하다보니 컴포넌트 간 넘겨받는 props도 많아지고, 이에 따라 변경사항이 있을 때 코드를 수정하는 시간이 길어졌다. 이를 어떻게 해결할 수 있을까 고민했을 때, **데이터 구조를 기반으로 컴포넌트를 나눠봤다.** 예를 들어, 댓글 작성, 댓글 수정, 대댓글 작성, 대댓글 수정은 모두 form이라는 형태를 사용하지만 사용하는 api와 비즈니스 로직은 다르다. 따라서 비슷한 컴포넌트라도 여러 개의 컴포넌트를 만드는게 좋다고 생각해 Create.CommentForm, Edit.CommentForm, CreateReplyForm 등으로 구분해서 만들어봤다. 그 외에 나머지 부분들도 같은 로직으로 처리했다.

props drilling을 해결하기 위해 context API를 사용했고, 로직 분리를 위해 custom hooks를 사용했다.

비슷한 구조의 컴포넌트가 많아졌지만 각 컴포넌트의 크기도 작아지고 컴포넌트 내부로직을 한 눈에 알아볼 수 있었다.

### CORS….

> 와이들카드나 localhost를 Access-Control-Allow-Origin에 쓰면 큰 의미가 없는 이유
> 이전에 proxy 서버가 단순히 cors를 막는 임시 방편으로 알고 있었고,
> 최종적으로는 서버에서 헤더 설정을 해야한다고 알고 있어 누가 쓰자고하면 안 좋다고 주장했다…
> 하지만 localhost까지 Access-Control-Allow-Origin에 포함시킬 필요는 없으니까 개발환경에서는 proxy를 통해 우회해도 괜찮은 것 같다!

로컬상태에서 다른 포트로 api를 요청하는 로직을 해결하기 쉽다. **`Access-Control-Allow-Origin`** 헤더에 알맞은 값을 세팅하면 된다. 물론, `**withCredentials**`옵션을 true로 설정한다면 와일드 카드가 아닌 특정 출처를 명시해야 한다.

위의 내용은 코드 스쿼드를 하면서 정리했던 내용이지만 **왜 이렇게 해야하는지에 대한 이해보다는 다른 블로그에서 이렇게 하던데?**라는 식의 방법이었다.

cors는 교차 출처에 대한 리소스를 안전하게 공유하기 위해 필요한 정책이다. 앞서 언급한대로 **`Access-Control-Allow-Origin`** 헤더에 알맞은 값을 세팅하면 되지만 흔히 우리는 와이들카드나 로컬에서 돌린 프론트포트(localhost)를 적곤한다. 물론 api서버도 로컬에서 돌리면 큰 문제가 없지만 배포된 api서버에도 위와 같인 헤더를 설정하면 cors가 해결하는 문제를 해결할 수 없다. `“*”`와일드 카드를 사용해서 쉽게 문제를 해결할 수도 있지만 모든 출처에 대한 요청을 수락하는 게 되어버려 보안적인 문제가 발생할 수 있기 때문이다. 당장에 문제는 쉽게 해결할 수 있지만 보안적으로 cors가 해결하는 문제를 해결하지 못하고 심각한 보안 이슈가 발생할 수 있다. `Access-Control-Allow-Origin`의 값으로 `프론트의 출처`를 넣어주면 해결된다. 그렇다고 `localhost:3000`같은 범용적인 출처를 적어준다면 앞서 언급한 `*` 와일드 카드와 같은 문제가 발생한다. 우리 가 배포할 프론트 서버의 출처를 적어야한다.

로컬 환경에서 **`/api`**로 시작하는 URL로 보내는 요청에 대해 브라우저는 **`localhost:3000/api`**
로 요청을 보낸 것으로 알고 있지만, 사실 뒤에서 특정 기능을 통해 `http://내 ec2 host`으로 요청을 프록싱해줘서 cors정책을 지킨것처럼 속이는 원리다.

아직까지 nignx로 해결하는 방법은 잘 이해하지 못했다.
