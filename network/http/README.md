# HTTP

HTTP는 HyperText Transfer Protocol의 약자로 서버-클라이언트 모델을 따르면서 request/response 구조로 웹 상에서 정보를 주고받을 수 있는 프로토콜입니다. TCP/IP 기반으로 작동하며, HTTP의 가장 큰 특징은 비-연결 지향(Connectionless와) 무상태성(Stateless) 입니다. HTTP는 기본적으로 리퀘스트(request)와 리스폰스(response)의 구조를 띄는데, 클라이언트가 요청을 보내면 서버는 응답을 보내는 구조입니다.

클라이언트-서버 모델을 따르는 프로토콜로 TCP/IP 위에서 동작하며 well-known 포트인 80번 포트를 사용하여 통신한다. 첫번째 표준은 HTTP/1.1이며 이후로 HTTP/2 및 HTTP/3가 등장하였다.

아래 내용은 HTTP/1.1에 관한 내용이다.

## HTTP 프로토콜의 특징

### 리퀘스트(request)와 리스폰스(response)

HTTP는 클라이언트로부터 요청(request)이 시작되며, 해당 요청을 서버가 응답(response)한다.

반드시 클라이언트로부터 통신이 시작되며, 서버 측에서 요청을 받지 않고 응답을 할 수 없다.

### 비-연결 지향 (Connectionless)

클라이언트가 서버에게 리소스를 요청한 후 응답을 받으면 연결을 끊어버리는 특징이다. 연결을 유지하게 되면 서버에 많은 부담을 줄 수 있기 때문에 상당히 많은 클라이언트에게 요청을 받는 웹 서버의 경우 응답을 처리했으면 연결을 끊는다.

이로 인해 서버의 부담을 줄일 수 있지만, 리소스를 요청할 때마다 연결해야 하는 오버헤드 비용이 발생한다. 이를 해결하기 위해선, 요청 헤더의 Connection: keep-alive 속성으로 지속적 연결 상태(Persistent connection)를 유지할 수 있다. 즉, 요청을 할 때마다 연결하지 않고 기존의 연결을 재사용하는 방식이다. HTTP 1.1 부턴 지속적 연결 상태가 기본이며 이를 해제하기 위해선 명시적으로 요청 헤더를 수정해야 한다.

### 무상태성 (Stateless)

HTTP는 상태를 저장하지 않는다.(Stateless). `각각의 요청은 독립적`이다. HTTP 프로토콜 레벨에서 이전에 보냈던 요청과 응답에 대해서 기억하지 않는다.

서버가 클라이언트의 상태를 유지하지 않기 때문에 쇼핑몰의 장바구니 같은 기능처럼 사용자가 일관된 방식으로 페이지와 상호작용할 때 문제가 된다.

HTTP의 핵심은 상태가 없는 것이지만 HTTP 쿠키는 상태가 있는 세션을 만들도록 해준다. 헤더 확장성을 사용하여, 동일한 컨텍스트 또는 동일한 상태를 공유하기 위해 각각의 요청들에 세션을 만들도록 HTTP 쿠키가 추가할 수 있다.

### 요청 URI로 리소스를 식별

HTTP는 URI(Uniform Resource Identifier)를 사용하여 리소스를 지정한다. HTTP 요청 대상을 "리소스"라고 하며 리소스의 특성은 더 이상 정의되지 않는다. 리소스는 문서, 사진 등으로 그 어떤 것이든 될 수 있다.

### 상태코드

HTTP status code는 클라이언트가 보낸 HTTP 요청에 대한 서버의 응답 코드로, 상태 코드를 통해 요청의 성공/실패 여부를 판단할 수 있따.

- 100번대부터 500번대까지 총 5개의 클래스로 구분되어 HTTP 요청에 대한 상태를 알려준다.

### 메서드

메서드란 요청 URI로 지정한 리소스에 요청을 보낼 때, 리소스에 어떠한 행동을 하기 원하는지 지시하기 위한 영어 동사 표현이다. `클라이언트가 서버에 요청방법을 정의하는 것으로 주어진 리소스에 수행하길 원하는 행동을 나타낸다.`

- GET : 서버에게 조회할 리소스를 요청한다. (READ, 조회)
- POST : 서버에게 본문(body)에 생성할 데이터를 삽입하여 전송한다. (CREATE, 생성)
- PUT : 서버에게 본문에 수정할 데이터를 삽입하여 전송한다. (UPDATE, 수정)
- DELETE : 서버에게 삭제할 리소스를 요청한다. (DELETE, 삭제)
- PATCH : PUT과 비슷하지만 일부만 수정한다는 점에서 다르다

### HTTP Method 의 멱등성

![멱등성](Understanding-Idempotency-and-Safety-in-API-Design.png)

- 사진 출처: https://nordicapis.com/understanding-idempotency-and-safety-in-api-design/

멱등성이 유지되어야 하는경우, 서버의 상태는 같은 행위를 여러 번 반복하더라도 같은 효과를 가져야 한다.

- POST를 제외하고는 모두(GET, POST, PUT, DELETE) 멱등성이 보장되어야 합니다. (PATCH는 설계에 따라 달라진다.)

올바르게 구현된 REST API 의 GET, HEAD, OPTIONS, PUT, DELETE 메소드는 통계 기록(e.g. 게시물 조회수의 증가 등)을 제외하였을 경우 멱등성이 보장된다.

#### 멱등성을 보장하는 메서드와 이유

- GET : 서버에 존재하는 리소스를 단순히 읽어오기만 하는 메소드이기 때문에 당연히 여러번 수행되어도 결과값은 변하지 않는다.
- PUT : 서버에 존재하는 리소스를 요청에 담긴 내용대로 통째로 대체해버리므로 올바르게 구현하였다면 여러번 수행되어도 결과 값은 변하지 않을 것 이다.
- DELETE : 존재하는 데이터를 삭제한 결과와 이미 존재하지 않은 결과를 삭제하려는 시도에 대한 응답 코드는 서로 다르겠지만, (200 OK 또는 404 NOT FOUND) 서버의 상태 자체는 변하지 않으므로 올바르게 구현되었다면 여러번 수행되어도 멱등성이 보장될 것 이다.

#### 멱등성을 보장하지 않는 메서드와 이유

- POST 메소드가 호출될 때 마다 데이터베이스 등에 요청된 데이터가 추가될 것 이고, 이는 곧 멱등성을 위배함을 알 수 있다. 호출시 마다 서버의 상태가 달라지기 때문이다.
- PATCH는 리소스의 일부에 대하여 변화를 명령할 수 있기 때문에 어떻게 설꼐하느냐에 따라 달라진다.

### 안전한 메소드 (Safe Methods)

안전한 메소드란, 서버의 상태를 변경시키지 않는 HTTP 메소드를 의미한다.

- GET과 같이 조회에 사용되는 메소드를 안전하다고 이야기할 수 있다. 모든 안전한 메소드는 멱등성을 갖지만, 그 역은 성립하지 않는다.
- PUT과 DELET 메소드는 멱등성을 갖는다. 하지만 PUT은 리소스를 수정하고, DELETE는 메소드를 제거하므로 안전한 메소드라고는 이야기할 수 없다.

즉, `멱등성을 갖는 메소드가 서버의 상태를 변경하지 않는다고 오해하면 안된다.` 멱등성을 갖는 메소드도 서버의 상태를 변경시킬 수 있다. 멱등성의 핵심은 "요청에 대한 서버의 상태가 항상 같은가?" 이다.

## HTTP1.x vs HTTP2.0

### HTTP1.1의 문제점

회전 지연(latency)

- HTTP 1.1의 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화되었다. 이로 인해 성능면에서 어느 정도 단점이 존재했다. 커넥션 하나를 통해 요청 하나를 보내고 그에 대한 응답을 받는 HTTP 메시지 교환 방식은 단순하지만, 응답을 받아야만 그 다음 요청을 보낼 수 있기 때문에 심각한 회전 지연(latency) 문제를 야기했다.
- 이 문제를 해결하기 위해 병렬 커넥션이나 파이프라인 커넥션이 도입되었지만 성능 개선에 대한 근본적인 해결책이 되지 못했다.

HOLB(Head Of Line Blocking)

- HTTP/1.1에 들어오면서 파이프라이닝(Pipelining) 기법을 통해 응답을 받지 않고도 여러개의 요청을 연속적으로 할 수 있게 되었다. 하지만 이 또한 처음의 요청에 대한 응답이 오래 걸리는 경우, 그 다음 응답까지의 시간이 지연되는 현상이 발생한다.
- 이렇게 파이프라이닝 기법은 심각한 문제를 안고 있었으며 이를 Head of Line Blocking 문제라고 부른다.

무겁고 중복 많은 헤더 구조

- 요청을 할 때 요청헤더에 메타정보를 넣어서 보내게 되는데, 매 요청마다 보내는 정보가 많아져서 헤더가 무거워지고 쿠키 같은 경우는 계속 보내게 되기 때문에 중복도 많아지는 문제가 있다.

### HTTP/2가 나오기 전의 개선방법들

- CSS/JavaScript/이미지 압축
- Data URI 스키마(이미지를 이진 파일로 바꿔 HTML에 넣어놓는 기법)
- Image Sprite(여러개의 작은 이미지들을 1번의 요청으로 받아오는 기법)
- 도메인 샤딩(1개의 도메인을 여러개의 서브도메인으로 나눠서 병렬요청하는 기법)
- 스크립트 파일을 </body> 직전에 배치해서 HTML/CSS 파싱 중단 안되게 설정

### HTTP2.0

HTTP2.0은 서버와 클라이언트 사이의 TCP커넥션 위에서 동작한다. 이때, TCP 커넥션을 초기화하는 것은 클라이언트다.

멀티플렉싱(Multiplexing)과 스트리밍(Streaming)

- HTTP 요청 데이터는 헤더와 본문으로 구성되는데 이를 각각 프레임(Frame)이라는 단위로 지정한다.
  - 모든 메시지는 프레임에 담겨 전송한다.
- 스트림(Stream)이라는 연결단위를 통해 헤더 프레임 혹은 본문 프레임을 보내도록 그 방식을 바꿨다.
  - 프레임에 담긴 요청과 응답은 스트림을 통해 보내진다.
  - 한 개의 스트름에 한 쌍의 요청과 응답을 처리한다.
- 하나의 스트림은 요청/응답으로 구성되고 여러개의 스트림을 생성할 수 있다. 바로 이것이 스트리밍을 통한 멀티플렉싱이다.
- 이를 통해 기존의 HTTP/1.1의 문제점인 HLOB를 해결할 수 있게 된다. 또한 요청한 리소스간의 우선순위를 설정하기 때문에 스트림 별로 가중치가 매겨지고 브라우저가 리소스들을 수신하는 순서를 적절하게 결정한다.

헤더 압축(Header Compression)

- 헤더 테이블(Header Table)을 사용하여 이전 헤더 정보를 유지하고 허프만 인코딩 기법으로 헤더를 압축해서 전송하여 중복과 크기를 줄인다.
- HTTP1.1에서 헤더는 아무런 압축 없이 그대로 전송되었다. 과거에는 웹페이지 하나를 방문할 때 요청이 많지 않기 때문에 문제가 되지 않았다.

서버 푸시(Server Push)

- HTTP2.0은 서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 해준다.
- 브라우저가 요청하지 않으면 서버는 응답하지 않는 것이 보통이지만, 요청한 HTML 문서에 리소스가 포함되어 있는 경우 서버가 브라우저에게 밀어주는(push) 방식을 취하여 브라우저의 요청을 최소화시킨다.
  - HTTP2의 서버 푸시를 활용하면 자원(JS, CSS, Image 등)을 하나의 TCP connection으로 클라이언트에 전달할 수 있다. 네트워크 활용도를 높여주고 빠른 로딩을 가능하게 한다..

## 참고자료

- http완벽가이드 - 데이빗 고울리 , 브라이언 토티 , 마조리 세이어, 세일루 레디, 안슈 아가왈  공저
- 그림으로 배우는 http & network - 우에노 센  저 / 이병억  역
- https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP
- https://github.com/brave-people/brave-tech-interview/blob/main/contents/network.md#http11-vs-http20
- https://github.com/baeharam/Must-Know-About-Frontend/blob/main/Notes/network/http.md
- https://meetup.nhncloud.com/posts/218
