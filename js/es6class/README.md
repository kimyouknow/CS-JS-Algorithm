# ES6 Class

이전까지 동일한 종류의 객체를 여러 개 생성해야할 경우, new 연산자와 생성자 함수를 활용해 new Function을 사용했다.

여기에 es6부터 도입 된 클래스(class) 문법을 사용하면 객체 지향 프로그래밍에서 사용되는 더 많은 기능을 사용할 수 있다.

새로운 문법은 특정 한계를 극복하기 위해 나왔다고 생각한다. 그렇다면 es6에서 class가 왜 새롭게 도입되었을까? 이에 대한 답으로 모던 자바스크립트 `25.1 클래스는 프로토타입의 문법적 설탕인가?` 의 내용을 참고했다.

> 단순히 문법적 설탕으로 보기보다는 새로운 객체 생성 메커니즘으로 보는 것이 조금 더 합당하다.

1. 자바스크립트는 프로토타입 기반 객체 지향언어이다. 프로토타입 기반 객체지향 언어는 클래스가 필요 없는 프로그래밍 언어다.
2. es6에서 도입된 class는 다른 클래스 기반 객체지향 프로그래밍 언어와 매우 흡사한 객체 매커니즘을 제공한다.
3. 클래스와 생성자 함수는 모두 프로토타입 기반 인스턴스를 생성하지만 정확히 동일하게 동작하지 않는다.



### 클래스와 생성자 함수 차이

- 특수 내부 프로퍼티인 `[[IsClassConstructor]]: true`가 붙음  

- 클래스는 `new` 없이 호출하면 에러 발생, 생성자 함수는 new 없이 호출하면 일반 함수로 호출
- 클래스는 상속을 지원하는 `extends, super`키워드 제공
- 클래스는 `호이스팅이 발생하지 않는 것`처럼 동작함.
- 클래스 내의 모든 코드에는 암묵적으로 `strict mode`가  실행되며 해제할 수 없음
- 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 `[[Emunerable]]의 값이 False`(열거되지 않음)

## 기본문법

---

### 0\. class 문법 구조

아래와 같은 class User{} 문법 구조

- User라는 함수 생성, 함수 본문은 생성자 매서드 constructor에서 가져옴.
- sayHi라는 클래스 내의 매서드는 User.prototype에 저장

```javascript
class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    alert(this.name);
  }
}

// 클래스는 함수입니다.
alert(typeof User); // function

// 정확히는 생성자 메서드와 동일합니다.
alert(User === User.prototype.constructor); // true

// 클래스 내부에서 정의한 메서드는 User.prototype에 저장됩니다.
alert(User.prototype.sayHi); // alert(this.name);

// 현재 프로토타입에는 메서드가 두 개입니다.
alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi
```

### 1\. 인스턴스 생성

`new User("dori")`  를 호출하면 다음과 같은 일이 발생

- 새로운 객체 생성
- 넘겨 받은 인수와 함께 constructor가 실행

### 2\. 표현식

함수처럼 클래스도 다른 표현식 내부에서 정의, 전달, 반환, 할당할 수 있다.

- `const user = class {}`
- 동적 생성 `function makeClass(){return class{}}`

### 3\. 상속

- `extends`

### 4\. 메서드 오버라이딩

- `uper.method(...)`는 부모 클래스에 정의된 메서드, `method`를 호출합니다.
- `super(...)`는 부모 생성자를 호출하는데, 자식 생성자 내부에서만 사용 할 수 있습니다.
- 화살표 함수는 `super`를 지원하지 않기 때문에 setTimeout같은 함수를 쓴다면 일반 함수가 아닌 화살표함수를 써서 상위 컨텍스트를 바라보게해야 super를 쓸 수 있음.

### 5\. 생성자 오버라이딩

- 일반 클래스가 `new`와 함께 실행되면, 빈 객체가 만들어지고 `this`에 이 객체를 할당
- 반면, 상속 클래스의 생성자 함수가 실행되면, 일반 클래스에서 일어난 일이 일어나지 않는다.
- 상속 클래스의 생성자 함수는 빈 객체를 만들고 `this`에 이 객체를 할당하는 일을 부모 클래스의 생성자가 처리해주길 기대
- 상속 클래스의 생성자에선 `super`를 호출해 부모 생성자를 실행해 주어야 함.. 그렇지 않으면 `this`가 될 객체가 만들어지지 않아 에러가 발생

### 6\. 정적 메서드와 정적 프로퍼티

- 클래스 안에서 `static` 키워드  

- `"prototype"`이 아닌 클래스 함수 자체에 메서드  

- 정적 메서드는 메서드를 프로퍼티 형태로 직접 할당하는 것과 동일한 일을 함.

  - ```javascript
    class User {}
    User.staticMethod = function () {};
    ```

  ```


  ```

- 정적 메서드는 어떤 특정한 객체가 아닌 클래스에 속한 함수를 구현하고자 할 때 주로 사용

  - 예를 들어, User 클래스로 생성한 여러 개의 인스턴스를 비교하고자 할때,  인스턴스의 메서드가 아닌 클래스의 메서드로 위에서 바라보며 비교하기

- 정적 프로퍼티도 가능, 아직 크롬에서만 지원함

### 7\. 정적 메서드와 프로퍼티 상속

- 정적 메서드와 프로퍼티 상속 가능
-

## 🔍 참고자료

---

모던 자바스크립트 25장 - \_클래스

[ko.javascript.info - 클래스](https://ko.javascript.info/classes)
